import logging
import sys
import csv
import config as cfg
import constants as const
import xmltodict, json
import pandas as pd
import random
import uuid
import time
from tabulate import tabulate
from policy import PolicyParser

def get_logger(name, path):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.FileHandler(path, mode='w')
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    # logger.disabled = True
    return logger

class TimerP(process):
    def setup(config):
        self.logger = get_logger('timer_logger', config['timer_log'])

    def run():
        # Kill after sending one message
        await(received(('DONE',)))


    def receive(msg= ('TIMER_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        time.sleep(payload['latency_in_secs'])
        del payload['latency_in_secs']
        send(('TIMER_RESPONSE', payload),to=p)
        self.logger.info('[SENT][TIMER_RESPONSE][{}] payload:{}'.format(payload['app_id'], payload))
        send(('DONE',),to=self.id)

class DBEmulator(process):
    def setup(config):
        self.conf = config['db_config']
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.logger = get_logger('db_logger', config['db_log'])
        self.attr_db = {}

        with open(self.conf, 'r') as f:
            db_data = f.read()

        json_content = json.loads(json.dumps(xmltodict.parse(db_data)))['db']

        json_data = json_content['data']
        for name in json_data:
            for data in json_data[name]:
                for attr in data['attr']:    
                    key = (name, data['id'], attr)
                    val = data['attr'][attr]
                    if not val:
                        val = 0 if attr in const.NUMERICAL_ATTR else ''
                            
                    self.attr_db[key] = int(val) if attr in const.NUMERICAL_ATTR else val

        # print (self.attr_db)

    def run():
        # print(self.tables)
        await(False)

    def _read(data):
        resp = dict(name=data['name'], id=data['id'], attr=dict())
        for attr_name in data['attr']:
            # print (attr_name)
            key = (data['name'], data['id'], attr_name)
            val = None
            if key in self.attr_db:
                val = self.attr_db[key]
            else:
                val = 0 if attr_name in const.NUMERICAL_ATTR else ''
                self.attr_db[key] = val

            resp['attr'][attr_name] = val

        return resp


    def _write(data):
        for attr in data['attr']:
            key = (data['name'], data['id'], attr)
            self.attr_db[key] = data['attr'][attr]

        return None

    def _op(fn, data):
        return fn(data)

    def receive(msg=('DB_READ_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_READ_REQUEST][{}] payload:{}'.format(data['app_id'], data))
        sub = self._op(self._read, data['sub'])
        res = self._op(self._read, data['res'])
        payload = dict(sub=sub, res=res, eval_id=data['eval_id'], app_id=data['app_id'])
        send(('DB_READ_RESPONSE', payload), to=p)
        self.logger.info('[SENT][DB_READ_RESPONSE][{}] payload:{}'.format(data['app_id'],payload))

    def receive(msg=('DB_WRITE_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_WRITE_REQUEST][{}] payload:{}'.format(data['app_id'], data))
        self._op(self._write, data['data'])

# Client corresponds to Application instance
class Application(process):
    def setup(sub_coord_ps, config):
        self.logger = get_logger('app_logger', config['app_log'])
        self.sub_coord_map = dict()

    # Assuming sub coordinator id as INTEGER
    def get_sub_coord(sub):
        sub_coords = list(sub_coord_ps)
        sub_coords.sort(key= lambda k: k._address[1])
        if sub['name'] not in sub_coord_map:
            self.sub_coord_map[sub['name']] = len(self.sub_coord_map)

        chosen = sub_coords[int(self.sub_coord_map[sub['name']])%len(sub_coords)]
        self.logger.info('SENDING SUB ID - {} TO PROCESS {}'.format(sub['id'], chosen))
        return chosen

    def authorize(sub, res, action):
        # time.sleep(1)
        app_id = str(uuid.uuid4())
        payload = {
            'sub': sub,
            'res': res,
            'action': action,
            'app_id':app_id
        }
        p = get_sub_coord(sub)

        send(('APP_EVALUATION_REQUEST',payload), to=p)
        self.logger.info('[SENT][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(app_id, payload))

    def run():
        sub = {
            'name':'customer',
            'attr': {},
            'id':'1'
        }
        res = {
            'name':'movie',
            'attr': {},
            'id':'1'
        }
        action = {
            'name': 'view'
        }
        authorize(sub, res, action)
        sub = {
            'name':'customer',
            'attr': {},
            'id':'1'
        }
        res = {
            'name':'movie1',
            'attr': {},
            'id':'2'
        }
        action = {
            'name': 'view'
        }
        authorize(sub, res, action)
        # sub = {
        #     'name':'customer',
        #     'attr': {},
        #     'id':'1'
        # }
        # res = {
        #     'name':'movie2',
        #     'attr': {},
        #     'id':'3'
        # }
        # action = {
        #     'name': 'view'
        # }
        # authorize(sub, res, action)
        sub = {
            'name':'employee',
            'attr': {},
            'id':'1'
        }
        res = {
            'name':'movie1',
            'attr': {},
            'id':'2'
        }
        await(False)

    def receive(msg=('APP_EVALUATION_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_id, payload))


class SubCoord(process):
    def setup(db_ps, res_coord_ps, config):
        self.logger = get_logger('sub_coord_logger', config['sub_coord_log'])
        self.app_req_map = dict()
        columns = ['eval_id','sub', 'res', 'action', 'dep_eval_ids', 'status', 'req_no','result']
        self.eval_cache = pd.DataFrame([], columns=columns)
        self.attr_cache = dict()
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.res_coord_map = dict()

    def get_res_coord(res):
        res_coords = list(res_coord_ps)
        res_coords.sort(key= lambda k: k._address[1])
        if res['name'] not in res_coord_map:
            self.res_coord_map[res['name']] = len(self.res_coord_map)
        chosen = res_coords[int(self.res_coord_map[res['name']])%len(res_coords)]
        self.logger.info('SENDING RES ID - {} TO PROCESS {}'.format(res['id'], chosen))
        return chosen

    def get_eval(eval_id):
        row = self.eval_cache[(self.eval_cache['eval_id'] == eval_id)]
        if len(row) > 0:
            return json.loads(row.iloc[0].to_json())
        else:
            return None


    def run():
        # await(received(('done', )))
        await(False)

    def setup_cache(eval_id, sub, res, action, dep_eval_ids, req_no, status):
        self.logger.info('[SETUP CACHE] [{}]'.format(eval_id))
        data = {'eval_id': eval_id,
                'sub': sub,
                'res': res,
                'action': action,
                'dep_eval_ids': dep_eval_ids,
                'req_no': req_no,
                'status':status,
                'result':None}

        self.eval_cache.loc[len(self.eval_cache)] = data

    def update_cache(eval_id):
        self.logger.info('[UPDATING CACHE] [{}]'.format(eval_id))
        indices = self.eval_cache.loc[(self.eval_cache['eval_id'] == eval_id)].index.tolist()
        if indices:
            self.eval_cache.set_value(indices[0], 'status', const.WORKER_COMPLETE)

    def update_attr(eval_id, sub, res, result):
        self.logger.info('[UPDATING ATTR] [{}]'.format(eval_id))
        indices = self.eval_cache.loc[(self.eval_cache['eval_id'] == eval_id)].index.tolist()
        if indices:
            self.eval_cache.set_value(indices[0],'sub', sub)
            self.eval_cache.set_value(indices[0],'res', res)
            self.eval_cache.set_value(indices[0],'result', result)

    def clear_cache(eval_id):
        self.logger.info('[CLEAR CACHE] [{}]'.format(eval_id))
        idx = self.eval_cache.loc[self.eval_cache['eval_id'] == eval_id].index.tolist()
        self.eval_cache.drop(idx, inplace=True)
        del self.app_req_map[eval_id]

    def restart(eval_id):
        self.logger.info('***[RESTARTING SELF]***')
        print('***[RESTARTING SELF]***')
        # eval = get_eval(eval_id)
        payload = {
            'sub': app_req_map[eval_id]['sub'],
            'res': app_req_map[eval_id]['res'],
            'action': app_req_map[eval_id]['action'],
            'app_id': app_req_map[eval_id]['app_id']
        }
        clear_cache(eval_id)
        send(('APP_EVALUATION_REQUEST',payload), to=self.id)
        self.logger.info('[SENT[APP_EVALUATION_REQUEST][{}] to [{}] payload:{}'
                         .format(payload['app_id'], self.id, payload))



    def add_tentative_attr_updates_to_req(sub, req_no):
        tentative_evals = get_previous_committed_evals(req_no)
        for eval in tentative_evals:
            attrs = eval['sub']['attr']
            for k in attrs:
                sub['attr'][k] = attrs[k]
        return sub, [eval['eval_id'] for eval in tentative_evals]

    def has_subject_attr_updates(eval_id):
        curr_eval = get_eval(eval_id)
        sub_attrs = curr_eval['sub']['attr']
        tentative_evals = get_tentative_evals(curr_eval['sub'], curr_eval['req_no'])
        tentative_attrs = {}
        for eval in tentative_evals:
            for k in sub_attrs:
                if k in eval['sub']['attr']:
                    tentative_attrs[k] = sub_attrs[k]

        for k in tentative_attrs:
            if tentative_attrs[k] != sub_attrs[k]:
                return True

        return False


    def evaluate(app_id, sub, res, action, req_no, p):
        eval_id = str(uuid.uuid4())
        app_req_map[eval_id] = dict(app_id=app_id, sub=sub, res=res, action=action, req_no=req_no, app_p=p)
        sub, dependent_eval_ids = add_tentative_attr_updates_to_req(sub, req_no)
        setup_cache(eval_id, sub, res, action, dependent_eval_ids, req_no, const.PENDING)
        return eval_id, sub

    def get_tentative_evals(sub, req_no):
        evals = self.eval_cache[(self.eval_cache['status'] == const.WORKER_COMPLETE) & (self.eval_cache['req_no'] < req_no)]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        eval_with_sub_attrs = []

        for eval in evals:
            for k in sub['attr']:
                if k in eval['sub']['attr']:
                    eval_with_sub_attrs.append(eval)
                    break

        return eval_with_sub_attrs

    def get_evals_dependent_on(eval_id):
        curr_eval = get_eval(eval_id)
        evals = self.eval_cache[(eval_id in self.eval_cache['dep_eval_ids']) & (self.eval_cache['req_no'] > curr_eval['req_no'])]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        return evals

    def get_app(eval_id):
        return self.app_req_map[eval_id]['app_p']

    def process_worker_response(eval_id, result):

        res = None

        eval = get_eval(eval_id)
        if eval:
            res = eval['res']

        if has_subject_attr_updates(eval_id):
            restart(eval_id)
        else:
            update_cache(eval_id)
            curr_eval = get_eval(eval_id)
            tentative_evals = get_tentative_evals(curr_eval['sub'], curr_eval['req_no'])

            tentative_eval_ids = set([x['eval_id'] for x in tentative_evals])
            if some(received(('RES_COMMIT_RESPONSE', payload)), has= payload['eval_id'] in tentative_eval_ids and payload['result'] == False):
                print('restarting eval_id = ', eval_id)
                restart(eval_id)
            else:
                return True, res
        return False, res

    def get_previous_committed_evals(req_no):
        evals = self.eval_cache[(self.eval_cache['status'] == const.WORKER_COMPLETE) & (self.eval_cache['req_no'] < req_no)]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        return evals

    def get_previous_evals(req_no):
        print ("REQ NO: ",req_no)
        # print (tabulate(self.eval_cache, headers='keys',tablefmt='psql'))
        evals = self.eval_cache[self.eval_cache['req_no'] < req_no]
        evals = evals.sort_values('req_no', ascending=True)
        # print (tabulate(evals, headers='keys',tablefmt='psql'))
        evals = json.loads(evals.to_json(orient="records"))
        return evals

    def update_attr_db(app_id, sub):
        payload = dict(app_id=app_id, sub=sub)
        for attr in sub['attr']:
            key = (sub['name'], sub['id'], attr)
            self.attr_cache[key] = sub['attr'][attr]

        seconds = random.randint(self.minLatency,self.maxLatency)
        payload = dict(app_id=app_id, latency_in_secs=seconds, sub=sub)

        timer_ps = new(TimerP, num=1)
        setup(timer_ps,(config,))
        start(timer_ps)

        send(('TIMER_REQUEST', payload),to=timer_ps)
        self.logger.info('[SENT][TIMER_REQUEST][{}] payload:{}'.format(app_id, payload))

    def commit_eval(app_id, eval_id):
        curr_eval = get_eval(eval_id)
        previous_evals = get_previous_evals(curr_eval['req_no'])
        previous_eval_ids = [x['eval_id'] for x in previous_evals]
        prev_evals_len = len(previous_evals)

        # print("BEFORE WAIT")
        print (previous_eval_ids)
        # if prev_evals_len > 0:

        #     # while True:
        #     if some(received(('RES_COMMIT_DONE', evl_id)), has= eval_id in previous_eval_ids):
        #         print(evl_id)
        #         previous_eval_ids.remove(evl_id)
        #         # if len(previous_eval_ids) == 0:
        #         #     break
        # else:
        update_attr_db(app_id, curr_eval['sub'])
        clear_cache(eval_id)    
        # print (eval_id)
        # print ("EVAL ID", eval_id)
        # previous_eval_ids.remove(payload['eval_id'])
        # prev_evals_len -= 1
        # print ("PREVIOUS EVAL IDS",previous_eval_ids)

        print("AFTER WAIT")

        

    def restart_dependent_evals(eval_id):
        print ("restarting dependant evals")
        evals = get_evals_dependent_on(eval_id)
        for eval in evals:
            restart(eval['eval_id'])

    def add_latest_db_updates(sub):
        ignore_attrs = []
        for attr in sub['attr']:
            key = (sub['name'], sub['id'], attr)
            if key in self.attr_cache:
                sub['attr'][attr] = self.attr_cache[key]
                del self.attr_cache[key]
            else:
                ignore_attrs.append(attr)

        for attr in ignore_attrs:
            del sub['attr'][attr]

        return sub

    def receive(msg= ('APP_EVALUATION_REQUEST', payload), from_=p):
        # print (tabulate(self.eval_cache, headers='keys',tablefmt='psql'))
        self.logger.info('[RECEIVED][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))

        res = payload['res']
        eval_id, sub = evaluate(payload['app_id'],
                                payload['sub'],
                                payload['res'],
                                payload['action'],
                                time.time(),
                                p)

        res_req_payload = dict(app_id=payload['app_id'],
                               eval_id=eval_id,
                               sub=sub,
                               res=res,
                               action=payload['action'])

        send(('RES_EVALUATION_REQUEST', res_req_payload),to=get_res_coord(res))
        self.logger.info('[SENT][RES_EVALUATION_REQUEST][{}] payload:{}'
                         .format(res_req_payload['app_id'], res_req_payload))

    def receive(msg= ('WORKER_EVALUATION_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        eval = get_eval(payload['eval_id'])
        if not eval:
            self.logger.info('[IGNORED][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
            return
        update_attr(payload['eval_id'], payload['sub'], payload['res'], payload['result'])
        status, res = process_worker_response(payload['eval_id'], payload['result'])
        # print("*********",status, res, "***********")
        # If control comes here then it should have been successful
        # Upon failure the process is restarted
        if status:
            res_commit_payload = dict(eval_id=payload['eval_id'],
                                      app_id=payload['app_id'],
                                      res=res)
            send(('RES_COMMIT_REQUEST', res_commit_payload),to=get_res_coord(res))
            self.logger.info('[SENT][RES_COMMIT_REQUEST][{}] payload:{}'
                             .format(res_commit_payload['app_id'], res_commit_payload))


    def receive(msg= ('RES_COMMIT_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        eval = get_eval(payload['eval_id'])
        if not eval:
            self.logger.info('[IGNORED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
            return
        
        print ('[RECEIVED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        result = payload['result']
        if result:
            app = get_app(payload['eval_id'])
            eval = get_eval(payload['eval_id'])
            commit_eval(payload['app_id'], payload['eval_id'])
            app_eval_payload = dict(result=eval['result'], app_id=payload['app_id'])
            send(('APP_EVALUATION_RESPONSE', app_eval_payload),to=app)
            self.logger.info('[SENT][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_eval_payload['app_id'], app_eval_payload))
            print('[SENT][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_eval_payload['app_id'], app_eval_payload))
            send(('RES_COMMIT_DONE', payload['eval_id']), to=self.id)
            
        else:
            restart_dependent_evals(payload['eval_id'])
            restart(payload['eval_id'])

    def receive(msg= ('TIMER_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))

        sub = add_latest_db_updates(payload['sub'])

        write_payload = dict(app_id=payload['app_id'], data=sub)
        send(('DB_WRITE_REQUEST', write_payload),to=db_ps)
        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'.format(payload['app_id'], write_payload))

class ResCoord(process):
    def setup(db_ps, workers, config):
        self.logger = get_logger('res_coord_logger', config['res_coord_log'])
        self.res_cache = dict()
        self.next_worker_idx = -1
        self.workers = list(workers)
        self.attr_cache = dict()
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']

    def run():
        await(False)

    # Selects worker in a round robin fashion
    def get_worker():
        self.next_worker_idx += 1
        return self.workers[next_worker_idx%len(self.workers)]

    def setup_res_attr(res):
        key = (res['name'], res['id'])
        if key in self.res_cache:
            res['attr'] = self.res_cache[key]

        return res

    def update_cache(res):
        key = (res['name'], res['id'])
        self.res_cache[key] = res['attr']


    def conflict_exists(res):
        key = (res['name'], res['id'])
        if key not in self.res_cache:
            return False

        cache_res = self.res_cache[key]
        for attr in res['old_attr']:
            if attr in cache_res and res['old_attr'][attr] != cache_res[attr]:
                return True

        return False


    def update_attr_db(app_id, res):
        payload = dict(app_id=app_id, res=res)
        for attr in res['attr']:
            key = (res['name'], res['id'], attr)
            self.attr_cache[key] = res['attr'][attr]

        seconds = random.randint(self.minLatency,self.maxLatency)
        payload = dict(app_id=app_id, latency_in_secs=seconds, res=res)

        timer_ps = new(TimerP, num=1)
        setup(timer_ps,(config,))
        start(timer_ps)

        send(('TIMER_REQUEST', payload),to=timer_ps)
        self.logger.info('[SENT][TIMER_REQUEST][{}] payload:{}'.format(app_id, payload))

    def commit_evaluation(app_id, eval_id, res):
        if conflict_exists(res):
            return False
        else:
            update_cache(res)
            update_attr_db(app_id, res)
            return True

    def add_latest_db_updates(res):
        ignore_attrs = []
        for attr in res['attr']:
            key = (res['name'], res['id'], attr)
            if key in self.attr_cache:
                res['attr'][attr] = self.attr_cache[key]
                del self.attr_cache[key]
            else:
                ignore_attrs.append(attr)

        for attr in ignore_attrs:
            del res['attr'][attr]

        return res

    def receive(msg= ('RES_EVALUATION_REQUEST', payload), from_=p):
        # print ("**************************************************")
        # print (self.res_cache)
        self.logger.info('[RECEIVED][RES_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        setup_res_attr(payload['res'])
        payload['sub_coord'] = p
        send(('WORKER_EVALUATION_REQUEST', payload),to=get_worker())

        self.logger.info('[SENT][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        # print (self.res_cache)
        # print ("**************************************************")

    def receive(msg= ('RES_COMMIT_REQUEST', payload), from_=p):
        # print ("**************************************************")
        # print (self.res_cache)
        self.logger.info('[RECEIVED][RES_COMMIT_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))

        result = commit_evaluation(payload['app_id'], payload['eval_id'], payload['res'])
        res_commit_payload = dict(eval_id=payload['eval_id'],
                                  result=result,
                                  app_id=payload['app_id'])

        seconds = 10 - int(payload['res']['id'])*2
        print ("sleeping {} by {}", payload['app_id'], seconds)
        time.sleep(seconds)
        send(('RES_COMMIT_RESPONSE', res_commit_payload),to=p)

        self.logger.info('[SENT][RES_COMMIT_RESPONSE][{}] payload:{}'
                             .format(res_commit_payload['app_id'], res_commit_payload))
        # print (self.res_cache)
        # print ("**************************************************")

    def receive(msg= ('TIMER_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))

        res = add_latest_db_updates(payload['res'])

        write_payload = dict(app_id=payload['app_id'], data=res)
        send(('DB_WRITE_REQUEST', write_payload),to=db_ps)
        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'.format(payload['app_id'], write_payload))

class Worker(process):
    def setup(db_ps, config):
        self.logger = get_logger('worker_logger', config['worker_log'])
        self.requests = dict()
        self.policy = PolicyParser()

    def evaluate(eval_id, sub, res, action, orig_res):
        # orig_res, _ = self.requests[eval_id]
        # change attr values based on policy rules
        # evaluate the policies
        res['old_attr'] = orig_res['attr']
        status, new_sub, new_res, action = self.policy.evaluate(sub, res, action)
        return status, new_sub, new_res, action

    def setup_payload(app_id, eval_id, sub, res):
        payload = {
            'app_id' : app_id,
            'eval_id' : eval_id,
            'sub':{
                'name':sub['name'],
                'id':sub['name'],
                'attr': list(self.policy.get_sub_attr(sub, res))
            },
            'res':{
                'name':res['name'],
                'id':res['id'],
                'attr': list(self.policy.get_res_attr(sub, res))
            }
        }
        return payload


    def run():
        await(False)

    def receive(msg= ('WORKER_EVALUATION_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        self.requests[payload['eval_id']] = (payload['sub'], payload['res'], payload['action'], payload['sub_coord'])

        # print(self.requests[payload['eval_id']])
        db_payload = setup_payload(payload['app_id'], payload['eval_id'], payload['sub'], payload['res'])

        db_payload['sub']['attr'] = [attr for attr in db_payload['sub']['attr'] if attr not in payload['sub']['attr']]
        db_payload['res']['attr'] = [attr for attr in db_payload['res']['attr'] if attr not in payload['res']['attr']]

        send(('DB_READ_REQUEST', db_payload), to=db_ps)
        self.logger.info('[SENT][DB_READ_REQUEST][{}] payload:{}'.format(payload['app_id'], payload))



    def receive(msg= ('DB_READ_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][DB_READ_RESPONSE][{}] payload:{}'.format(payload['app_id'], payload))

        orig_sub, orig_res, orig_action, sub_coord_ps = self.requests[payload['eval_id']]
        payload['sub']['attr'].update(orig_sub['attr'])
        payload['res']['attr'].update(orig_res['attr'])
        result, sub, res, action = evaluate(payload['eval_id'], payload['sub'], payload['res'], orig_action, orig_res)
        print(result, sub, res, action)
        worker_resp_payload = dict(eval_id=payload['eval_id'],
                                   result=result,
                                   sub=sub,
                                   res=res,
                                   action=action,
                                   app_id=payload['app_id'])

        send(('WORKER_EVALUATION_RESPONSE', worker_resp_payload),to=sub_coord_ps)

        self.logger.info('[SENT][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(worker_resp_payload['app_id'], worker_resp_payload))


def main():
    config_fpath = sys.argv[1] if len(sys.argv) > 1 else "../config/main-config.json"
    config = cfg.load_config(config_fpath)
    # do something with config
    config(channel="reliable")


    db_ps = new(DBEmulator, num=1)
    setup(db_ps,(config,))
    start(db_ps)

    worker_ps = new(Worker, num=config['num_coords']*config['worker_count'])
    setup(worker_ps,(db_ps, config,))
    start(worker_ps)

    res_coord_ps = new(ResCoord, num=config['num_coords'])
    setup(res_coord_ps,(db_ps, worker_ps, config,))
    start(res_coord_ps)

    sub_coord_ps = new(SubCoord, num=config['num_coords'])
    setup(sub_coord_ps,(db_ps, res_coord_ps, config,))
    start(sub_coord_ps)

    app_ps = new(Application, num=config['num_clients'])
    setup(app_ps,(sub_coord_ps, config,))
    start(app_ps)
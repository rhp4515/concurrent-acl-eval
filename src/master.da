import logging
import sys
import csv
import config as cfg
import constants as const
import xmltodict, json
import pandas as pd
import random
import uuid
import time
from tabulate import tabulate
from policy import PolicyParser

def get_logger(name, path):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.FileHandler(path, mode='w')
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    logger.disabled = True
    return logger

class DBEmulator(process):
    def setup(config):
        self.conf = config['db_config']
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.logger = get_logger('db_logger', config['db_log'])
        self.attr_db = {}

        # with open(self.conf, 'r') as f:
        #     db_data = f.read()

        # json_content = json.loads(json.dumps(xmltodict.parse(db_data)))['db']

        # json_schema = json_content['schema']
        # for schema in json_schema:
        #     self.tables[schema] = pd.DataFrame([], columns=json_schema[schema]['column'])

        # json_data = json_content['data']

        # for table in json_data:
        #     self.tables[table] = pd.read_json(json.dumps(json_data[table]))

    def run():
        # print(self.tables)
        await(False)

    def _read(data):
        resp = dict(name=data['name'], id=data['id'], attr=dict())
        for attr_name in data['attr']:
            print (attr_name)
            key = (data['name'], data['id'], attr_name)
            val = None
            if key in self.attr_db:
                val = self.attr_db[key]
            else:
                if attr_name in const.NUMERICAL_ATTR:
                    val = 0
                else:
                    val = ''
                self.attr_db[key] = val

            resp['attr'][attr_name] = val

        return resp


    def _write(data):
        for attr in data['attr']:
            key = (data['name'], data['id'], attr)
            self.attr_db[key] = data['attr'][attr]

        return None

    def _op(fn, data):
        # should we use this flag or jus delay for every operation ?
        # should we delay the operation or literally mimic the visibility?
        # if later, we gotta think more about the design.. former is jus
        # removing the condition and jus delay for everything
        # if data['delay']:
        #     time.sleep(random.randint(self.minLatency,self.maxLatency))

        payload = fn(data)
        # print ("************ ATTR DB **************")
        # print (self.attr_db)
        return payload


    def receive(msg=('DB_READ_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_READ_REQUEST][{}] payload:{}'.format(data['app_id'], data))
        sub = self._op(self._read, data['sub'])
        res = self._op(self._read, data['res'])
        payload = dict(sub=sub, res=res, eval_id=data['eval_id'], app_id=data['app_id'])
        send(('DB_READ_RESPONSE', payload), to=p)
        self.logger.info('[SENT][DB_READ_RESPONSE][{}] payload:{}'.format(data['app_id'],payload))

    def receive(msg=('DB_WRITE_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_WRITE_REQUEST][{}] payload:{}'.format(data['app_id'], data))
        self._op(self._write, data['sub'])

# Client corresponds to Application instance
class Application(process):
    def setup(sub_coord_ps, config):
        self.logger = get_logger('app_logger', config['app_log'])

    # Assuming sub coordinator id as INTEGER
    def get_sub_coord(sub):
        sub_coords = list(sub_coord_ps)
        sub_coords.sort(key= lambda k: k._address[1])
        chosen = sub_coords[int(sub['id'])%len(sub_coords)]
        self.logger.info('SENDING SUB ID - {} TO PROCESS {}'.format(sub['id'], chosen))
        return chosen

    def authorize(sub, res):
        app_id = str(uuid.uuid4())
        payload = {
            'sub':sub,
            'res':res,
            'action':'read',
            'app_id':app_id
        }
        p = get_sub_coord(sub)

        send(('APP_EVALUATION_REQUEST',payload), to=p)
        self.logger.info('[SENT][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(app_id, payload))

    def run():
        sub = {
            'name':'customer',
            'attr': {},
            'id':'1'
        }
        res = {
            'name':'movie',
            'attr': {},
            'id':'1'
        }
        authorize(sub, res)
        time.sleep(1)
        sub = {
            'name':'employee',
            'attr': {},
            'id':'1'
        }
        res = {
            'name': 'bank A',
            'attr': {},
            'id': '1'
        }
        authorize(sub, res)
        # time.sleep(1)
        # sub = {
        #     'name':'customer',
        #     'attr': {'value':2,'count':3},
        #     'id':'1'
        # }
        # authorize(sub, res)
        await(False)

    def receive(msg=('APP_EVALUATION_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_id, payload))


class SubCoordP(process):
    def setup(db_ps, res_coord_ps, config):
        self.logger = get_logger('sub_coord_logger', config['sub_coord_log'])
        self.app_req_map = dict()
        columns = ['eval_id','sub', 'res', 'dep_eval_ids', 'status', 'req_no']
        self.eval_cache = pd.DataFrame([], columns=columns)

    def get_res_coord(res):
        res_coords = list(res_coord_ps)
        res_coords.sort(key= lambda k: k._address[1])
        chosen = res_coords[int(res['id'])%len(res_coords)]
        self.logger.info('SENDING RES ID - {} TO PROCESS {}'.format(res['id'], chosen))
        return chosen

    def get_eval(eval_id):
        row = self.eval_cache[(self.eval_cache['eval_id'] == eval_id)]
        if len(row) > 0:
            return json.loads(row.iloc[0].to_json())
        else:
            return None


    def run():
        # await(received(('done', )))
        await(False)

    def setup_cache(eval_id, sub, res, dep_eval_ids, req_no, status):
        self.logger.info('[SETUP CACHE] [{}]'.format(eval_id))
        data = {'eval_id': eval_id,
                'sub': sub,
                'res': res,
                'dep_eval_ids': dep_eval_ids,
                'req_no': req_no,
                'status':status}

        self.eval_cache.loc[len(self.eval_cache)] = data

    def update_cache(eval_id):
        self.logger.info('[UPDATING CACHE] [{}]'.format(eval_id))
        indices = self.eval_cache.loc[(self.eval_cache['eval_id'] == eval_id)].index.tolist()
        if indices:
            self.eval_cache.set_value(indices[0], 'status', const.WORKER_COMPLETE)

    def update_attr(eval_id, sub, res):
        self.logger.info('[UPDATING ATTR] [{}]'.format(eval_id))
        indices = self.eval_cache.loc[(self.eval_cache['eval_id'] == eval_id)].index.tolist()
        if indices:
            self.eval_cache.set_value(indices[0],'sub', sub)
            self.eval_cache.set_value(indices[0],'res', res)

    def clear_cache(eval_id):
        self.logger.info('[CLEAR CACHE] [{}]'.format(eval_id))
        idx = self.eval_cache.loc[self.eval_cache['eval_id'] == eval_id].index.tolist()
        self.eval_cache.drop(idx, inplace=True)
        del self.app_req_map[eval_id]

    def restart(eval_id):
        self.logger.info('***[RESTARTING SELF]***')
        eval = get_eval(eval_id)
        payload = {
            'sub': app_req_map[eval_id]['sub'],
            'res': app_req_map[eval_id]['res'],
            'app_id': app_req_map[eval_id]['app_id']
        }
        clear_cache(eval_id)
        send(('APP_EVALUATION_REQUEST',payload), to=self.id)
        self.logger.info('[SENT[APP_EVALUATION_REQUEST][{}] to [{}] payload:{}'
                         .format(payload['app_id'], self.id, payload))


    def add_tentative_attr_updates_to_req(sub, req_no):
        tentative_evals = get_tentative_evals(sub, req_no)
        for eval in tentative_evals:
            attrs = eval['sub']['attr']
            for k in attrs:
                if k in sub['attr']:
                    sub['attr'][k] = attrs[k]
        return sub, [eval['eval_id'] for eval in tentative_evals]

    def has_subject_attr_updates(eval_id):
        curr_eval = get_eval(eval_id)
        sub_attrs = curr_eval['sub']['attr']
        tentative_evals = get_tentative_evals(curr_eval['sub'], curr_eval['req_no'])
        tentative_attrs = {}
        for eval in tentative_evals:
            for k in sub_attrs:
                if k in eval['sub']['attr']:
                    tentative_attrs[k] = sub_attrs[k]

        for k in tentative_attrs:
            if tentative_attrs[k] != sub_attrs[k]:
                return True

        return False


    def evaluate(app_id, sub, res, req_no, p):
        eval_id = str(uuid.uuid4())
        app_req_map[eval_id] = dict(app_id=app_id, sub=sub, res=res, req_no=req_no, app_p=p)
        sub, dependent_eval_ids = add_tentative_attr_updates_to_req(sub, req_no)
        setup_cache(eval_id, sub, res, dependent_eval_ids, req_no, const.PENDING)
        return eval_id, sub

    def get_tentative_evals(sub, req_no):
        evals = self.eval_cache[(self.eval_cache['status'] == const.WORKER_COMPLETE) & (self.eval_cache['req_no'] < req_no)]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        eval_with_sub_attrs = []

        for eval in evals:
            for k in sub['attr']:
                if k in eval['sub']['attr']:
                    eval_with_sub_attrs.append(eval)
                    break

        return eval_with_sub_attrs

    def get_evals_dependent_on(eval_id):
        curr_eval = get_eval(eval_id)
        evals = self.eval_cache[(eval_id in self.eval_cache['dep_eval_ids']) & (self.eval_cache['req_no'] > curr_eval['req_no'])]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        return evals

    def get_app(eval_id):
        return self.app_req_map[eval_id]['app_p']

    def process_worker_response(eval_id, result):

        res = None

        eval = get_eval(eval_id)
        if eval:
            res = eval['res']

        if has_subject_attr_updates(eval_id):
            restart(eval_id)
        else:
            update_cache(eval_id)
            curr_eval = get_eval(eval_id)
            tentative_evals = get_tentative_evals(curr_eval['sub'], curr_eval['req_no'])

            tentative_eval_ids = set([x['eval_id'] for x in tentative_evals])
            if some(received(('RES_COMMIT_RESPONSE', payload)), has= payload['eval_id'] in tentative_eval_ids and payload['result'] == False):
                print('restarting eval_id = ', eval_id)
                restart(eval_id)
            else:
                return True, res
        return False, res

    def get_previous_evals(req_no):
        evals = self.eval_cache[self.eval_cache['req_no'] < req_no]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        return evals

    def update_attr_db(app_id, sub):
        payload = dict(app_id=app_id, sub=sub)
        send(('DB_WRITE_REQUEST', payload),to=db_ps)
        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'.format(app_id, payload))

    def commit_eval(app_id, eval_id):
        curr_eval = get_eval(eval_id)
        previous_evals = get_previous_evals(curr_eval['req_no'])
        previous_eval_ids = [x['eval_id'] for x in previous_evals]
        prev_evals_len = len(previous_evals)

        while prev_evals_len > 0:
            await(some(received(('RES_COMMIT_RESPONSE', payload)), has= payload['eval_id'] in previous_eval_ids and payload['result'] == True))
            previous_eval_ids.remove(payload['eval_id'])
            prev_evals_len -= 1

        update_attr_db(app_id, curr_eval['sub'])
        clear_cache(eval_id)

    def restart_dependent_evals(eval_id):
        print ("restarting dependant eva;s")
        evals = get_evals_dependent_on(eval_id)
        for eval in evals:
            restart(eval['eval_id'])

    def receive(msg= ('APP_EVALUATION_REQUEST', payload), from_=p, clk=rclk):
        print (tabulate(self.eval_cache, headers='keys',tablefmt='psql'))
        self.logger.info('[RECEIVED][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))

        res = payload['res']
        eval_id, sub = evaluate(payload['app_id'],
                                payload['sub'],
                                payload['res'],
                                rclk,
                                p)
        res_req_payload = dict(app_id=payload['app_id'],
                               eval_id=eval_id,
                               sub=sub,
                               res=res)

        send(('RES_EVALUATION_REQUEST', res_req_payload),to=get_res_coord(res))
        self.logger.info('[SENT][RES_EVALUATION_REQUEST][{}] payload:{}'
                         .format(res_req_payload['app_id'], res_req_payload))

    def receive(msg= ('WORKER_EVALUATION_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        update_attr(payload['eval_id'], payload['sub'], payload['res'])
        status, res = process_worker_response(payload['eval_id'], payload['result'])
        # print("*********",status, res, "***********")
        # If control comes here then it should have been successful
        # Upon failure the process is restarted
        if status:
            res_commit_payload = dict(eval_id=payload['eval_id'],
                                      app_id=payload['app_id'],
                                      res=res)
            send(('RES_COMMIT_REQUEST', res_commit_payload),to=get_res_coord(res))
            self.logger.info('[SENT][RES_COMMIT_REQUEST][{}] payload:{}'
                             .format(res_commit_payload['app_id'], res_commit_payload))


    def receive(msg= ('RES_COMMIT_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        result = payload['result']
        if result:
            app = get_app(payload['eval_id'])
            commit_eval(payload['app_id'], payload['eval_id'])
            app_eval_payload = dict(result=payload['result'], app_id=payload['app_id'])
            send(('APP_EVALUATION_RESPONSE', app_eval_payload),to=app)
            self.logger.info('[SENT][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_eval_payload['app_id'], app_eval_payload))
        else:
            restart_dependent_evals(payload['eval_id'])
            restart(payload['eval_id'])


class ResCoordP(process):
    def setup(workers, config):
        self.logger = get_logger('res_coord_logger', config['res_coord_log'])
        self.res_cache = dict()
        self.next_worker_idx = -1
        self.workers = list(workers)

    def run():
        await(False)

    # Selects worker in a round robin fashion
    def get_worker():
        self.next_worker_idx += 1
        return self.workers[next_worker_idx%len(self.workers)]

    def setup_res_attr(res):
        key = (res['name'], res['id'])
        if key in self.res_cache:
            res['attr'] = self.res_cache[key]

        return res

    def update_cache(res):
        key = (res['name'], res['id'])
        self.res_cache[key] = res['attr']


    def conflict_exists(res):
        key = (res['name'], res['id'])
        if key not in self.res_cache:
            return False

        cache_res = self.res_cache[key]
        for attr in res['old_attr']:
            if attr in cache_res and res['old_attr'][attr] != cache_res[attr]:
                return True

        return False


    def update_attr_db(res):
        # TODO: Write the updates to db after constructing db
        # send(('DB_WRITE_REQUEST', sub),to=db_ps)
        # self.logger.info('[SENT][DB_WRITE_REQUEST] payload:{}'.format(sub))

        # jus update the resource attrs
        return

    def commit_evaluation(eval_id, res):
        if conflict_exists(res):
            print ("exist conflict")
            return False
        else:
            update_cache(res)
            update_attr_db(res)
            return True

    def receive(msg= ('RES_EVALUATION_REQUEST', payload), from_=p):
        # print ("**************************************************")
        # print (self.res_cache)
        self.logger.info('[RECEIVED][RES_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        setup_res_attr(payload['res'])
        payload['sub_coord'] = p
        send(('WORKER_EVALUATION_REQUEST', payload),to=get_worker())

        self.logger.info('[SENT][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        # print (self.res_cache)
        # print ("**************************************************")

    def receive(msg= ('RES_COMMIT_REQUEST', payload), from_=p):
        # print ("**************************************************")
        # print (self.res_cache)
        self.logger.info('[RECEIVED][RES_COMMIT_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))

        result = commit_evaluation(payload['eval_id'], payload['res'])
        res_commit_payload = dict(eval_id=payload['eval_id'],
                                  result=result,
                                  app_id=payload['app_id'])

        send(('RES_COMMIT_RESPONSE', res_commit_payload),to=p)

        self.logger.info('[SENT][RES_COMMIT_RESPONSE][{}] payload:{}'
                             .format(res_commit_payload['app_id'], res_commit_payload))
        # print (self.res_cache)
        # print ("**************************************************")

class WorkerP(process):
    def setup(db_ps, config):
        self.logger = get_logger('worker_logger', config['worker_log'])
        self.requests = dict()
        self.policy = PolicyParser()

    def evaluate(eval_id, sub, res, orig_res):
        # orig_res, _ = self.requests[eval_id]
        # change attr values based on policy rules
        # evaluate the policies
        res['old_attr'] = orig_res['attr']

        return False, sub, res

    def get_sub_attr(sub, res):
        return list(self.policy.get_sub_attr(sub))

    def get_res_attr(sub, res):
        return list(self.policy.get_res_attr(res))

    def setup_payload(app_id, eval_id, sub, res):
        payload = {
            'app_id' : app_id,
            'eval_id' : eval_id,
            'sub':{
                'name':sub['name'],
                'id':sub['name'],
                'attr': get_sub_attr(sub, res)
            },
            'res':{
                'name':res['name'],
                'id':res['id'],
                'attr':get_res_attr(sub, res),
            }
        }
        return payload


    def run():
        await(False)

    def receive(msg= ('WORKER_EVALUATION_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        self.requests[payload['eval_id']] = (payload['res'], payload['sub_coord'])

        db_payload = setup_payload(payload['app_id'], payload['eval_id'], payload['sub'], payload['res'])

        send(('DB_READ_REQUEST', db_payload), to=db_ps)
        self.logger.info('[SENT][DB_READ_REQUEST][{}] payload:{}'.format(payload['app_id'], payload))



    def receive(msg= ('DB_READ_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][DB_READ_RESPONSE][{}] payload:{}'.format(payload['app_id'], payload))

        orig_res, sub_coord_ps = self.requests[payload['eval_id']]
        result, sub, res = evaluate(payload['eval_id'], payload['sub'], payload['res'], orig_res)

        worker_resp_payload = dict(eval_id=payload['eval_id'],
                                   result=result,
                                   sub=sub,
                                   res=res,
                                   app_id=payload['app_id'])

        send(('WORKER_EVALUATION_RESPONSE', worker_resp_payload),to=sub_coord_ps)

        self.logger.info('[SENT][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(worker_resp_payload['app_id'], worker_resp_payload))


def main():
    config_fpath = sys.argv[1] if len(sys.argv) > 1 else "../config/main-config.json"
    config = cfg.load_config(config_fpath)
    # do something with config
    config(channel="reliable", clock="Lamport")


    db_ps = new(DBEmulator, num=1)
    setup(db_ps,(config,))
    start(db_ps)

    worker_ps = new(WorkerP, num=config['num_coords']*config['worker_count'])
    setup(worker_ps,(db_ps, config,))
    start(worker_ps)

    res_coord_ps = new(ResCoordP, num=config['num_coords'])
    setup(res_coord_ps,(worker_ps, config,))
    start(res_coord_ps)

    sub_coord_ps = new(SubCoordP, num=config['num_coords'])
    setup(sub_coord_ps,(db_ps, res_coord_ps, config,))
    start(sub_coord_ps)

    app_ps = new(Application, num=config['num_clients'])
    setup(app_ps,(sub_coord_ps, config,))
    start(app_ps)
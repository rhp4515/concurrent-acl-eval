import logging
import sys
import csv
import config as cfg
import constants as const
import xmltodict
import json
import pandas as pd
import random
import uuid
import time
import copy
from threading import Lock
from tabulate import tabulate
from policy import PolicyParser
from random import shuffle


def get_logger(name, path):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.FileHandler(path, mode='w')
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    # logger.disabled = True
    return logger

class TimerP(process):
    def setup(config, suffix):
        self.logger = get_logger('timer_logger',
                                 config['timer_log'].format('',''))

    def run():
        # Kill after sending one message
        await(received(('DONE',)))


    def receive(msg= ('TIMER_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        time.sleep(payload['latency_in_secs'])
        del payload['latency_in_secs']
        send(('TIMER_RESPONSE', payload),to=p)
        self.logger.info('[SENT][TIMER_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        send(('DONE',),to=self)

class DBEmulator(process):
    def setup(config, suffix, p_time):
        self.conf = config['db_config']
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.logger = get_logger('db_logger', config['db_log'].format(suffix))
        self.attr_db = {}

        with open(self.conf, 'r') as f:
            db_data = f.read()

        self.logger.info("--- INITIALIZING DB INSTANCE WITH GIVEN DATA ---")
        json_content = json.loads(json.dumps(xmltodict.parse(db_data)))['db']

        if json_content and 'data' in json_content:
            json_data = json_content['data']
        else:
            json_data = []

        for ent_type in json_data:
            if type(json_data[ent_type]) == dict:
                json_data[ent_type] = [json_data[ent_type]]

            for data in json_data[ent_type]:
                for attr in data['attr']:
                    key = (ent_type, data['id'], attr)
                    val = data['attr'][attr]
                    if not val:
                        val = 0 if attr in const.NUMERICAL_ATTR else ''
                    self.attr_db[key] = int(val) if attr in const.NUMERICAL_ATTR else val

        self.logger.info('[INITIAL_STATE][DB_DUMP] db_dump:{}'
                                                .format(self.attr_db))

    def run():
        await(False, timeout=p_time)
        self.logger.info('[FINAL_STATE][DB_DUMP] db_dump:{}'
                                                .format(self.attr_db))

    def _read(data):
        """ Operation to read data from db """
        resp = dict(type=data['type'], id=data['id'], attr=dict())
        for attr_name in data['attr']:
            key = (data['type'], data['id'], attr_name)
            val = None
            if key in self.attr_db:
                val = self.attr_db[key]
            else:
                val = 0 if attr_name in const.NUMERICAL_ATTR else ''
                self.attr_db[key] = val

            resp['attr'][attr_name] = val

        return resp


    def _write(data):
        """ Operation to write data to db """
        for attr in data['attr']:
            key = (data['type'], data['id'], attr)
            self.attr_db[key] = data['attr'][attr]

        return None

    def _op(fn, data):
        return fn(data)

    def receive(msg=('DB_READ_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_READ_REQUEST][{}] payload:{}'
                                                .format(data['app_id'], data))
        # sub = self._op(self._read, data['sub'])
        # res = self._op(self._read, data['res'])

        # payload = dict( sub=sub,
        #                 res=res,
        #                 eval_id=data['eval_id'],
        #                 app_id=data['app_id'])

        send(('DB_READ_RESPONSE', data), to=p)
        self.logger.info('[SENT][DB_READ_RESPONSE][{}] payload:{}'
                                                .format(data['app_id'],data))


    def receive(msg=('DB_WRITE_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_WRITE_REQUEST][{}] payload:{}'
                                                .format(data['app_id'], data))
        self._op(self._write, data['data'])

# Client corresponds to Application instance
#TODO implement pending queue
class Application(process):
    def setup(coord_ps, config, requests, suffix, coord_map):
        self.logger = get_logger('app_logger', config['app_log'].format(suffix, str(self)))
        self.requests = requests
        self.coord_map = coord_map
        self.read_write_map = dict()
        self.pending_q = dict()

    def analyze_policies(sub, res, action):
        p = PolicyParser()
        self.read_write_map.update(p.get_read_write_map(sub, res, action))

    def predict_objs (sub , res , action ):
        self.analyze_policies(sub, res, action)
        req_type = const.READ_WRITE
        key = (sub['type'], res['type'], action['type'])
        if key not in read_write_map:
            req_type = const.READ_ONLY
            return (sub, res, action, req_type)

        r_type , w_type = read_write_map[key]
        if res['type'] == r_type :
            return (res, sub, action, req_type)
        else :
            return (sub, res, action, req_type)

    def get_coord(obj):
        """
            Create subject to subject coordinator map and returns subject
            coordinator process id
        """
        coords = list(coord_ps)

        # Sorting source coordinator process by its address to maintain
        # consistency
        coords.sort(key= lambda k: k.uid)

        # Making evaluations for a resource is map to corresponding resource
        # coordinator
        idx = int(self.coord_map[obj['type']])%len(coords)
        chosen = coords[idx]
        self.logger.info('Coord process for {} -> {}'.format(obj['type'],
                                                                     chosen))
        return chosen

    def authorize(sub, res, action, delays, app_id):
        if 'attr' not in sub:
            sub['attr'] = dict()
        if 'attr' not in res:
            res['attr'] = dict()

        # print(delays)
        if 'delay' in delays:
            if type(delays['delay']) == str:
                delays = [delays['delay']]
            else:
                delays = delays['delay']
        else:
            delays = []

        r_obj, w_obj, action, req_type = predict_objs(sub, res, action)
        r_obj['coord'] = get_coord(r_obj)
        w_obj['coord'] = get_coord(w_obj)

        payload=dict(app_id=app_id,
                     r_obj=r_obj,
                     w_obj=w_obj,
                     action=action,
                     req_type=req_type,
                     delays=delays)

        timer_ps = new(TimerP, args=(config,suffix,))
        start(timer_ps)

        timer_payload = dict(app_id=app_id, latency_in_secs=2)
        send(('TIMER_REQUEST', timer_payload), to=timer_ps)
        self.logger.info('[SENT][TIMER_REQUEST][{}] payload:{}'
                                        .format(app_id, timer_payload))

        send(('COORDR_REQUEST', payload), to=r_obj['coord'])
        self.logger.info('[SENT][COORDR_REQUEST][{}] payload:{}'
                                                .format(app_id, payload))

    def send_and_receive(app_id, request):

        authorize(  request['sub'],
                    request['res'],
                    request['action'],
                    request.get('delays', {}),
                    app_id)

        # Serializing request evaluation
        await(some(received(('DONE', payload)), has= payload == app_id ))
        self.logger.info('[RECEIVED][DONE]')

    def run():
        # print('num requests = ', len(self.requests))
        for request in self.requests:
            # Creating an app id for the subject coordinator to send the response
            # to corresponding application
            app_id = str(uuid.uuid4())
            req_copy = copy.deepcopy(request)
            self.pending_q[app_id] = request
            send_and_receive(app_id, req_copy)

    def restart(app_id):
        req = self.pending_q.get(app_id, None)
        if req is None :
            return
        else :
            new_app_id = uuid.uuid4()
            self.pending_q[new_app_id] = req
            send_and_receive(new_app_id, req)
            self.logger.info('[RESTART][REQUEST][{}][{}] payload:{}'
                                        .format(app_id, new_app_id, req))

    def receive(msg=('CLIENT_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][CLIENT_RESPONSE][{}] payload:{}'
                                                    .format(app_id, payload))

        del self.pending_q[app_id]
        send(('DONE', app_id), to=self)

    def receive(msg=('TIMER_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                                                    .format(app_id, payload))

        if app_id in self.pending_q:
            restart(app_id)

class Coord(process):
    def setup(db_ps, workers, config, suffix,coord_map):
        self.logger = get_logger('res_coord_logger',
                                 config['res_coord_log'].format(suffix,
                                                                str(self)))
        self.res_cache = dict()
        self.next_worker_idx = -1
        self.workers = list(workers)
        self.attr_version = dict()
        self.attr_cache = dict()
        self.write_updates_cache = dict()
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']

    def run():
        await(False)

    def get_worker():
        """ Selects worker in a round robin fashion """
        self.next_worker_idx += 1
        return self.workers[next_worker_idx%len(self.workers)]

    def latest_version_before(x, attr, ts):
        result = dict(rts=0, wts=0, pending_might_read=[])
        attr_versions = [t for t in attr_version.keys() if t[0] == x['type'] and t[1] in x['attr']]

        attr_versions.sort(key= lambda k: k[2])

        for attr_v in attr_versions:
            _, attr, attr_ts = attr_v
            if attr_ts < ts:
                return attr_version[attr_v]

        return result

    def check_conflict(response):
        for attr in response['updated_obj']['updates']:
            v = self.latest_version_before(response['updated_obj'], attr, response['ts'])
            if v['rts'] > response['ts']:
                return True
        return False


    def restart(response):
        pass

    def analyze_policies(payload):
        r_type = payload['r_obj']['type']
        w_type = payload['w_obj']['type']
        a_type = payload['action']['type']

        # print(">>>>>>>>>>>>>>>>>>", r_type, w_type, a_type)
        attrs = dict()

        p = PolicyParser()

        r_attrs = p.get_all_attrs(r_type)
        w_attrs = p.get_all_attrs(w_type)

        # print(">>>>>>>>>>>>>>>>>>", r_attrs)
        # print(">>>>>>>>>>>>>>>>>>", w_attrs)

        attrs[r_type] = dict()
        attrs[r_type]['def_r_attr'] = []
        attrs[r_type]['might_r_attr'] = []

        attrs[w_type] = dict()
        attrs[w_type]['def_r_attr'] = []
        attrs[w_type]['might_r_attr'] = []

        for attr in r_attrs:
            if attr in p.attrs_in_matching_policies(r_type, w_type, a_type):
                attrs[r_type]['def_r_attr'].append(attr)
            else:
                attrs[r_type]['might_r_attr'].append(attr)

        for attr in w_attrs:
            if attr in p.attrs_in_matching_policies(r_type, w_type, a_type):
                attrs[r_type]['def_r_attr'].append(attr)
            else:
                attrs[r_type]['might_r_attr'].append(attr)

        return attrs

    def update_req(x, payload):
        attrs = self.analyze_policies(payload)
        def_read_attrs = attrs[x['type']]['def_r_attr']
        might_read_attrs = attrs[x['type']]['might_r_attr']
        # print(">>>>>>>", x['type'])
        # print(">>>>>>>", def_read_attrs, might_read_attrs)
        # print(">>>>>>>", payload)
        if payload['req_type'] == const.READ_ONLY:
            for attr in def_read_attrs:
                v = self.latest_version_before(x, a, time.time())
                v['rts'] = payload['ts']
        else:
            might_read_attrs.extend(def_read_attrs)

        for attr in might_read_attrs:
            v = self.latest_version_before(x, attr, time.time())
            v['pending_might_read'].append((payload['eval_id'], payload['ts']))

        # Piggy backing on cached data
        for attr in set(def_read_attrs+might_read_attrs):
            # print(">>>>>>>", attr)
            # print("-------", x)

            key = (x['type'], x['id'], attr)
            if key in self.attr_cache:
                x['attr'][attr] = self.attr_cache[key]

        return payload

    def update_attr_db(type, updates, ts):
        pass

    def receive(msg= ('COORDR_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][COORDR_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        x = payload['r_obj']
        payload['eval_id'] = str(uuid.uuid4())
        payload['ts'] = time.time()
        payload['app_ps'] = p
        payload = self.update_req(x, payload)
        send(('COORDW_REQUEST', payload),to=payload['w_obj']['coord'])

        self.logger.info('[SENT][COORDW_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))

    def receive(msg= ('COORDR_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][COORDR_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))

        x = payload['obj']
        attrs = self.analyze_policies(payload)

        might_read_attrs = attrs[x['type']]['might_r_attr']

        for attr in might_read_attrs:
            v = self.latest_version_before(x, attr, payload['ts'])
            v['pending_might_read'] = [x for x in v['pending_might_read'] if x[0] != payload['eval_id']]
            if attr in payload['read_attrs']:
                v['rts'] = payload['ts']

        self.logger.info('[PROCESSED][COORDR_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))

    def receive(msg= ('COORDW_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][COORDW_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))

        x = payload['w_obj']
        payload = self.update_req(x, payload)
        worker = self.get_worker()

        send(('WORKER_REQUEST', payload), to=worker)
        self.logger.info('[SENT][WORKER_REQUEST][{}] payload:{}'
                                        .format(payload['app_id'],
                                                payload))

    def receive(msg= ('COORDW_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][COORDW_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        if not self.check_conflict(payload):
            x = payload['updated_obj']
            attr_updates = payload['updated_obj']['updates']
            write_updates_cache[payload['eval_id']] = payload['updated_obj']['updates']['attrs']

            #await
            if not self.check_conflict(payload):
                self.update_attr_db(x['type'], x['updates'], payload['ts'])

                del write_updates_cache[payload['eval_id']]

                for attr in x['updates']:
                    key = (x['type'], x['id'], attr)
                    attr_cache[key] = x['updates'][attr]

                for attr in x['updates']:
                    key = (x['type'], attr, payload['ts'])
                    attr_version[key] = dict(rts=payload['ts'],
                                             wts=payload['ts'],
                                             pending_might_read=[])

                attrs = analyze_policies(payload)
                def_read_attrs = attrs[x['type']]['def_r_attr']
                might_read_attrs = attrs[x['type']]['might_r_attr']

                for attr in set(def_read_attrs+might_read_attrs):
                    v = self.latest_version_before(x, attr, payload['ts'])
                    v['pending_might_read'] = [x for x in v['pending_might_read'] if x[0] != payload['eval_id']]
                    if attr in payload['read_attrs'][x['type']]:
                        v['rts'] = payload['ts']


                client_resp_payload = dict(result=payload['result'],
                                       app_id=payload['app_id'])

                send(('CLIENT_RESPONSE', client_resp_payload), to=payload['app_ps'])
                self.logger.info('[SENT][CLIENT_RESPONSE][{}] payload:{}'
                                            .format(client_resp_payload['app_id'],
                                                    client_resp_payload))

                if x['type'] == payload['w_obj']['type']:
                    payload['obj'] = payload['r_obj']

                else:
                    payload['obj'] = payload['w_obj']

                payload['read_attrs'] = payload['read_attrs'][payload['obj']['type']]
                send(('COORDR_RESPONSE', payload), to=payload['obj']['coord'])
                self.logger.info('[SENT][COORDR_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'],
                                                    payload))
            else:
                restart(payload)
        else:
            restart(payload)

    def receive(msg= ('TIMER_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))


        # write_payload = dict(app_id=payload['app_id'], data=res)
        # send(('DB_WRITE_REQUEST', write_payload),to=db_ps)

        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'
                                      .format(payload['app_id'], payload))

class Worker(process):

    def setup(db_ps, config, suffix):
        self.logger = get_logger('worker_logger',
                                 config['worker_log'].format(suffix,
                                                             str(self)))
        self.requests = dict()


    def evaluate(eval_id, sub, res, action, orig_res):
        # orig_res, _ = self.requests[eval_id]
        # change attr values based on policy rules
        # evaluate the policies
        res['old_attr'] = orig_res['attr']
        # print("!!!!!!!!!!!!!!!!!!!!!!!")
        # print(sub)
        # print(res)
        policy = PolicyParser()
        status, new_sub, new_res, action = policy.evaluate(sub, res, action)
        # print(new_sub)
        # print(new_res)
        # print("!!!!!!!!!!!!!!!!!!!!!!!")
        return status, new_sub, new_res, action


    def setup_payload(app_id, eval_id, sub, res):
        policy = PolicyParser()

        sub_attrs = list(policy.get_sub_attr(sub, res))
        res_attrs = list(policy.get_res_attr(sub, res))

        sub = dict(type=sub['type'], id=sub['id'], attr=sub_attrs)
        res = dict(type=res['type'], id=res['id'], attr=res_attrs)

        payload = dict(app_id=app_id, eval_id=eval_id, sub=sub, res=res)
        return payload


    def run():
        await(False)


    def receive(msg= ('WORKER_REQUEST', payload), from_=p):

        self.logger.info('[RECEIVED][WORKER_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        # self.requests[payload['eval_id']] = (payload['sub'],
        #                                      payload['res'],
        #                                      payload['action'],
        #                                      payload['sub_coord'])

        # db_payload = setup_payload(payload['app_id'], payload['eval_id'],
        #                                         payload['sub'], payload['res'])

        # db_payload['sub']['attr'] = [attr for attr in db_payload['sub']['attr']
        #                                 if attr not in payload['sub']['attr']]

        # db_payload['res']['attr'] = [attr for attr in db_payload['res']['attr']
        #                                 if attr not in payload['res']['attr']]

        # # Hacks to introduce artifical delays for simulating few tests
        # if 'before_db_read' in payload['delays']:
        #     time.sleep(10)

        send(('DB_READ_REQUEST', payload), to=db_ps)

        self.logger.info('[SENT][DB_READ_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))



    def receive(msg= ('DB_READ_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][DB_READ_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        # eval_id = payload['eval_id']
        # orig_sub, orig_res, orig_action, coord_ps = self.requests[eval_id]
        # payload['sub']['attr'].update(orig_sub['attr'])
        # payload['res']['attr'].update(orig_res['attr'])

        # if len(orig_res['attr']) == 0:
        #     orig_res['attr'] = copy.deepcopy(payload['res']['attr'])

        # result, sub, res, action = evaluate(payload['eval_id'], payload['sub'],
        #                                     payload['res'], orig_action,
        #                                     orig_res)
        # # print(result, sub, res, action)
        result = False
        client_resp_payload = dict(result=result,
                                   app_id=payload['app_id'])

        # if worker_resp_payload['res']['id'].isdigit():
        #     seconds = 20 - int(worker_resp_payload['res']['id'])
        # else:
        #     seconds = random.randint(1,10)
        # print ("sleeping {} by {}", worker_resp_payload['app_id'], seconds)
        # time.sleep(seconds)
        # if 'before_worker_response' in payload['delays']:
        #     time.sleep(10)
        send(('CLIENT_RESPONSE', client_resp_payload), to=payload['app_ps'])

        self.logger.info('[SENT][CLIENT_RESPONSE][{}] payload:{}'
                                        .format(client_resp_payload['app_id'],
                                                client_resp_payload))


def parse_client_requests(fpath):
    """ Method to parse client request file """
    with open(fpath, 'r') as f:
        cli_data = f.read()
        json_content = json.dumps(xmltodict.parse(cli_data)).replace('@','')
        requests = json.loads(json_content)['requests']['request']
    return requests


def gen_reqs(conf):
    total_reqs = conf['num_clients'] * conf['workload']
    reqs = []
    test_truth = dict()
    while total_reqs > len(reqs):
        # shuffle(conf['subs'])
        # shuffle(conf['res'])
        conf['subs'] = conf['subs'][1:]
        conf['subs'].append('A')
        for sub in conf['subs']:
            # sub_id = str(random.randint(1, conf['num_clients']/2))
            sub_id = str(random.randint(1,1))
            for res in conf['res']:

                # res_id = str(random.randint(1, conf['num_clients']/2))
                res_id = str(random.randint(1,1))
                req = {
                    'sub': {
                        'type':sub,
                        'id':sub_id
                    },
                    'res': {
                        'type':res,
                        'id':res_id
                    },
                    'action' : {
                        'type':conf['action']
                    }
                }
                if sub.lower() == res:
                    key = (res, res_id, 'viewCount')
                    if key in test_truth:
                        test_truth[key] += 1
                    else:
                        test_truth[key] = 1
                reqs.append(req)

    print(test_truth)
    # print (len(reqs))
    with open(conf['test_truth_path'], 'w') as f:
        f.write(json.dumps(str(test_truth)))

    with open(conf['path'],'w') as f:
        f.write(json.dumps(reqs))

    return reqs


def main():
    DEFAULT_MAIN_CONFIG = "../config/main-config.json"
    config_fpath = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_MAIN_CONFIG
    config = cfg.load_config(config_fpath)
    config(channel="reliable")

    for test in config['testing']:
        suffix = test['log_suffix']
        p_time = test['p_time']
        if test.get('generate', None):
            cli_requests = gen_reqs(test)
            test['workload'] = [test['workload']] * test['num_clients']
        else:
            cli_requests = parse_client_requests(test['path'])
            if test['randomize']:
                random.seed(test['seed'])
                shuffle(cli_requests)

        types = set([x['sub']['type'] for x in cli_requests])
        types = types.union(set([x['res']['type'] for x in cli_requests]))
        coord_map = dict()
        for type in types:
            coord_map[type] = len(coord_map)

        print ('coord_map', coord_map)

        # Setup and start DBEmulator
        db_ps = new(DBEmulator, args=(config, suffix, p_time,))
        # setup(db_ps,)
        start(db_ps)

        # Setup and start Workers
        worker_ps = new(Worker, num=test['num_coords']*test['worker_count'], args=(db_ps, config, suffix,))
        # setup(worker_ps,)
        start(worker_ps)

        # Setup and start Resource Coordinators

        workers_p = list(worker_ps)
        start = 0
        coords = set()
        for i in range(test['num_coords']):
            coord_ps = new(Coord, args=(db_ps, workers_p[start:start+test['worker_count']], config, suffix,
                    coord_map,))
            # setup(p,)
            start(coord_ps)
            coords.add(coord_ps)
            start += test['worker_count']


        # Setup and start Application instances

        print (coords)
        i = 0
        start = 0

        for i in range(test['num_clients']):
            app_ps = new(Application, num=1, args=(coords, config,
                        cli_requests[start:start+test['workload'][i]], suffix,
                        coord_map,))
            # setup(p, )
            start += test['workload'][i]
            i += 1
            start(app_ps)
            if test.get('serialize_app_req_delay', None):
                time.sleep(1)


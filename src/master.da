import logging
import sys
import csv
import config as cfg
import constants as const
import xmltodict, json
import pandas as pd
import random
import uuid
import time

def get_logger(name, path):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.FileHandler(path, mode='w')
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    return logger

class DBEmulator(process):
    def setup(config):
        self.conf = config['db_config']
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.logger = get_logger('db_logger', config['db_log'])
        self.tables = {}
        
        with open(self.conf, 'r') as f:
            db_data = f.read()
        
        json_content = json.loads(json.dumps(xmltodict.parse(db_data)))['db']
        
        json_schema = json_content['schema']
        for schema in json_schema:
            self.tables[schema] = pd.DataFrame([], columns=json_schema[schema]['column'])

        json_data = json_content['data']    

        for table in json_data:
            self.tables[table] = pd.read_json(json.dumps(json_data[table]))
        
    def run():
        print(self.tables)
        await(False)
    
    def _read(df, data):
        row = df[(df['id'] == data['id'])]
        if len(row) > 0:
            return row.iloc[0].to_json()
        else:
            new_data = []
            # print( list(df.cols))
            cols = df.columns
            
            for col in cols:
                for k in data:
                    df.ix[len(df), k] =  data[k]

            # df.loc[] = data                
            return data

    def _write(df, data):
        index = df.loc[(df['id'] == data['id'])].index.tolist()
        if len(index) > 0:
            for k in data:
                df.ix[index[0], k] =  data[k]
        else:
            df.loc[len(df)] =  data

        return data

    def _op(fn, data):
        # should we use this flag or jus delay for every operation ?
        # should we delay the operation or literally mimic the visibility?
        # if later, we gotta think more about the design.. former is jus 
        # removing the condition and jus delay for everything
        if data['delay']:
            time.sleep(random.randint(self.minLatency,self.maxLatency))
        
        payload = fn(self.tables[data['table']], data['payload'])
        print (self.tables[data['table']])
        
        return payload
        

    def receive(msg=('DB_READ', data), from_=p):
        self.logger.info('[DB_READ_REQ] payload:{}'.format(data))
        payload = self._op(self._read, data)
        send(('DB_READ_RESPONSE', payload),to=p)
        self.logger.info('[DB_READ_RESP] payload:{}'.format(data))

    def receive(msg=('DB_WRITE', data), from_=p):
        self.logger.info('[DB_WRITE_REQ] payload:{}'.format(data))
        payload = self._op(self._write, data)
        send(('DB_WRITE_RESPONSE', payload),to=p)
        self.logger.info('[DB_WRITE_RESP] payload:{}'.format(data))

# Client corresponds to Application instance
class Application(process):
    def setup(sub_coord_ps, config):
        self.logger = get_logger('app_logger', config['app_log'])
        # print(coord_ps)
        pass

    def get_sub_coord(sub):
        return list(sub_coord_ps)[0]

    def authorize(sub, res):
        app_id = str(uuid.uuid4())
        payload = {
            'sub':sub,
            'res':res,
            'app_id': app_id
        }
        p = get_sub_coord(sub)
        print(p)
        send(('APP_EVALUATION_REQUEST',payload), to=p)
        self.logger.info('[SENT][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(app_id, payload))
    
    def run():
        sub = {
            'type':'customer',
            'id':'1'
        }
        res = {
            'type':'movie',
            'id':'1'
        }
        authorize(sub, res)
        await(False)

    def receive(msg=('APP_EVALUATION_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_id, payload))



class SubCoordP(process):
    def setup(config):
        self.logger = get_logger('sub_coord_logger', config['sub_coord_log'])

    def run():
        await(False)

    def receive(msg= ('APP_EVALUATION_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        send(('APP_EVALUATION_RESPONSE', payload),to=p)
        self.logger.info('[SENT][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))

    def receive(msg= ('WORKER_EVALUATION_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        # send(('APP_EVALUATION_RESPONSE', payload),to=p)
        output('Need to process the worker response')

    def receive(msg= ('RES_COMMIT_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        output('Need to process the resource commit response')


class ResCoordP(process):
    def setup(workers, config):
        self.logger = get_logger('res_coord_logger', config['res_coord_log'])
        output('Number of workers = ', len(workers))

    def run():
        await(False)

    def receive(msg= ('SUB_EVALUATION_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][SUB_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        output('Need to process the subject evaluation request')

    def receive(msg= ('RES_COMMIT_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        output('Need to verify resource commit request')


class WorkerP(process):
    def setup(config):
        self.logger = get_logger('worker_logger', config['worker_log'])

    def run():
        await(False)

    def receive(msg= ('WORKER_EVALUATION_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        output('Need to process the worker evaluation request')


def main():
    config_fpath = sys.argv[1] if len(sys.argv) > 1 else "../config/main-config.json"
    config = cfg.load_config(config_fpath)
    # do something with config
    config(channel="fifo", clock="Lamport")

    db_ps = new(DBEmulator, num=1)
    setup(db_ps,(config,))
    start(db_ps)

    sub_coord_ps = new(SubCoordP, num=config['num_coords'])
    setup(sub_coord_ps,(config,))
    start(sub_coord_ps)

    worker_ps = new(WorkerP, num=config['num_coords']*config['worker_count'])
    setup(worker_ps,(config,))
    start(worker_ps)

    res_coord_ps = new(ResCoordP, num=config['num_coords'])
    setup(res_coord_ps,(worker_ps, config,))
    start(res_coord_ps)


    app_ps = new(Application, num=config['num_clients'])
    setup(app_ps,(sub_coord_ps, config,))
    start(app_ps)
import logging
import sys
import csv
import config as cfg
import constants as const
import xmltodict
import json
import pandas as pd
import random
import uuid
import time
import copy
from threading import Lock
from tabulate import tabulate
from policy import PolicyParser
from random import shuffle


def get_logger(name, path):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.FileHandler(path, mode='w')
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    # logger.disabled = True
    return logger

class TimerP(process):
    def setup(config, suffix):
        self.logger = get_logger('timer_logger',
                                 config['timer_log'].format('',''))

    def run():
        # Kill after sending one message
        await(received(('DONE',)))


    def receive(msg= ('TIMER_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        time.sleep(payload['latency_in_secs'])
        del payload['latency_in_secs']
        send(('TIMER_RESPONSE', payload),to=p)
        self.logger.info('[SENT][TIMER_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        send(('DONE',),to=self)

class DBEmulator(process):
    def setup(config, suffix, p_time):
        self.conf = config['db_config']
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.logger = get_logger('db_logger', config['db_log'].format(suffix))
        self.attr_db = {}

        with open(self.conf, 'r') as f:
            db_data = f.read()

        self.logger.info("--- INITIALIZING DB INSTANCE WITH GIVEN DATA ---")
        json_content = json.loads(json.dumps(xmltodict.parse(db_data)))['db']

        if json_content and 'data' in json_content:
            json_data = json_content['data']
        else:
            json_data = []

        for ent_type in json_data:
            if type(json_data[ent_type]) == dict:
                json_data[ent_type] = [json_data[ent_type]]

            for data in json_data[ent_type]:
                for attr in data['attr']:
                    key = (ent_type, data['id'], attr)
                    val = data['attr'][attr]
                    if not val:
                        val = 0 if attr in const.NUMERICAL_ATTR else ''
                    self.attr_db[key] = int(val) if attr in const.NUMERICAL_ATTR else val

        self.logger.info('[INITIAL_STATE][DB_DUMP] db_dump:{}'
                                                .format(self.attr_db))

    def run():
        await(False, timeout=p_time)
        self.logger.info('[FINAL_STATE][DB_DUMP] db_dump:{}'
                                                .format(self.attr_db))

    def _read(data, ts):
        """ Operation to read data from db """
        resp = dict(type=data['type'], id=data['id'], attr=dict())
        for attr_name in data['attr']:
            key = (data['type'], data['id'], attr_name)
            val = None

            attr_keys = [k for k in self.attr_db.keys() if k[0] == key[0] and k[1] == key[1] and k[2] == key[2] and k[3] < ts]
            # print (">>>>>>>>>>>>>>>>>",attr_keys)
            if len(attr_keys):
                attr_keys.sort(key= lambda k: k[3], reverse=True)
                attr_key_v = attr_keys[0]
                val = self.attr_db[attr_key_v]
            else:
                val = 0 if attr_name in const.NUMERICAL_ATTR else ''
                key = (data['type'], data['id'], attr_name, ts)
                self.attr_db[key] = val

            resp['attr'][attr_name] = val

        return resp


    def _write(data):
        """ Operation to write data to db """
        for attr in data['updates']:
            key = (data['type'], data['id'], attr, data['ts'])
            self.attr_db[key] = data['updates'][attr]

        return None

    def receive(msg=('DB_READ_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_READ_REQUEST][{}] payload:{}'
                                                .format(data['app_id'], data))
        ts = data['ts']
        data['r_obj'] = self._read(data['r_obj'], ts)
        data['w_obj'] = self._read(data['w_obj'], ts)

        # payload = dict( sub=sub,
        #                 res=res,
        #                 eval_id=data['eval_id'],
        #                 app_id=data['app_id'])


        send(('DB_READ_RESPONSE', data), to=p)
        self.logger.info('[SENT][DB_READ_RESPONSE][{}] payload:{}'
                                                .format(data['app_id'],data))


    def receive(msg=('DB_WRITE_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_WRITE_REQUEST][{}] payload:{}'
                                                .format(data['app_id'], data))
        self._write(data['data'])

# Client corresponds to Application instance
#TODO implement pending queue
class Application(process):
    def setup(coord_ps, config, requests, suffix, coord_map):
        self.logger = get_logger('app_logger', config['app_log'].format(suffix, str(self)))
        self.requests = requests
        self.coord_map = coord_map
        self.read_write_map = dict()
        self.pending_q = dict()

    def analyze_policies(sub, res, action):
        p = PolicyParser()
        self.read_write_map.update(p.get_read_write_map(sub, res, action))

    def predict_objs (sub , res , action ):
        self.analyze_policies(sub, res, action)
        req_type = const.READ_WRITE
        key = (sub['type'], res['type'], action['type'])
        if key not in read_write_map:
            req_type = const.READ_ONLY
            return (sub, res, action, req_type)

        r_type , w_type = read_write_map[key]
        if res['type'] == r_type :
            return (res, sub, action, req_type)
        else :
            return (sub, res, action, req_type)

    def get_coord(obj):
        """
            Create subject to subject coordinator map and returns subject
            coordinator process id
        """
        coords = list(coord_ps)

        # Sorting source coordinator process by its address to maintain
        # consistency
        coords.sort(key= lambda k: k.uid)

        # Making evaluations for a resource is map to corresponding resource
        # coordinator
        idx = int(self.coord_map[obj['type']])%len(coords)
        chosen = coords[idx]
        self.logger.info('Coord process for {} -> {}'.format(obj['type'],
                                                                     chosen))
        return chosen

    def authorize(sub, res, action, delays, app_id):
        if 'attr' not in sub:
            sub['attr'] = dict()
        if 'attr' not in res:
            res['attr'] = dict()

        # print(delays)
        if 'delay' in delays:
            if type(delays['delay']) == str:
                delays = [delays['delay']]
            else:
                delays = delays['delay']
        else:
            delays = []

        r_obj, w_obj, action, req_type = predict_objs(sub, res, action)
        r_obj['coord'] = get_coord(r_obj)
        w_obj['coord'] = get_coord(w_obj)

        payload=dict(app_id=app_id,
                     r_obj=r_obj,
                     w_obj=w_obj,
                     action=action,
                     req_type=req_type,
                     delays=delays)

        timer_ps = new(TimerP, args=(config,suffix,))
        start(timer_ps)

        # timer_payload = dict(app_id=app_id, latency_in_secs=10)
        # send(('TIMER_REQUEST', timer_payload), to=timer_ps)
        # self.logger.info('[SENT][TIMER_REQUEST][{}] payload:{}'
        #                                 .format(app_id, timer_payload))

        send(('COORDR_REQUEST', payload), to=r_obj['coord'])
        self.logger.info('[SENT][COORDR_REQUEST][{}] payload:{}'
                                                .format(app_id, payload))

    def send_and_receive(app_id, request):

        authorize(  request['sub'],
                    request['res'],
                    request['action'],
                    request.get('delays', {}),
                    app_id)

        # Serializing request evaluation
        await(some(received(('DONE', payload)), has= payload == app_id ))
        self.logger.info('[RECEIVED][DONE]')

    def run():
        # print('num requests = ', len(self.requests))
        for request in self.requests:
            # Creating an app id for the subject coordinator to send the response
            # to corresponding application
            app_id = str(uuid.uuid4())
            req_copy = copy.deepcopy(request)
            self.pending_q[app_id] = request
            send_and_receive(app_id, req_copy)

    def restart(app_id):
        req = self.pending_q.get(app_id, None)
        if req is None :
            return
        else :
            new_app_id = uuid.uuid4()
            self.pending_q[new_app_id] = req
            send_and_receive(new_app_id, req)
            self.logger.info('[RESTART][REQUEST][{}][{}] payload:{}'
                                        .format(app_id, new_app_id, req))

    def receive(msg=('CLIENT_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][CLIENT_RESPONSE][{}] payload:{}'
                                                    .format(app_id, payload))

        del self.pending_q[app_id]
        send(('DONE', app_id), to=self)

    def receive(msg=('TIMER_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                                                    .format(app_id, payload))

        if app_id in self.pending_q:
            restart(app_id)

class Coord(process):
    def setup(db_ps, workers, config, suffix,coord_map):
        self.logger = get_logger('res_coord_logger',
                                 config['res_coord_log'].format(suffix,
                                                                str(self)))
        self.res_cache = dict()
        self.next_worker_idx = -1
        self.workers = list(workers)
        self.attr_version = dict()
        self.attr_cache = dict()
        self.write_updates_cache = dict()
        self.req_q = dict()
        self.starvation_q = dict()
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']

    def run():
        await(False)

    def get_worker():
        """ Selects worker in a round robin fashion """
        self.next_worker_idx += 1
        return self.workers[next_worker_idx%len(self.workers)]

    def latest_version_before(x, attr, ts):
        # print (x, attr, ts)
        result = dict(rts=0, wts=0, pending_might_read=[])
        attr_versions = [t for t in attr_version.keys() if t[0] == x['type'] and t[1] == attr]

        attr_versions.sort(key= lambda k: k[2])
        # print (attr_versions)

        for attr_v in attr_versions:
            _, _, attr_ts = attr_v
            # print (attr_ts, ts)
            if attr_ts < ts:
                return attr_version[attr_v]

        key = (x['type'], attr, ts)
        self.attr_version[key] = result
        return result

    def check_conflict(response):
        for attr in response['updated_obj']['updates']:
            v = self.latest_version_before(response['updated_obj'], attr, response['ts'])
            if v['rts'] > response['ts']:
                return True
        return False


    def restart(payload):
        print("*****************    RESTARTING     *******************")
        if payload['r_obj']['type'] == payload['updated_obj']['type']:
            payload['r_obj'], payload['w_obj'] = payload['w_obj'], payload['r_obj']

        # Removing this request from all cache and starting fresh
        del self.req_q[payload['eval_id']]
        del self.write_updates_cache[payload['eval_id']]
        del self.starvation_q[payload['eval_id']]

        send(('COORDR_REQUEST', payload), to=payload['r_obj']['coord'])
        self.logger.info('[SENT][COORDR_REQUEST][{}] payload:{}'
                                                .format(payload['app_id'], payload))

    def analyze_policies(payload):
        r_type = payload['r_obj']['type']
        w_type = payload['w_obj']['type']
        a_type = payload['action']['type']

        # print(">>>>>>>>>>>>>>>>>>", r_type, w_type, a_type)
        attrs = dict()

        p = PolicyParser()

        r_attrs = p.get_all_attrs(r_type)
        w_attrs = p.get_all_attrs(w_type)

        # print(">>>>>>>>>>>>>>>>>>", r_attrs)
        # print(">>>>>>>>>>>>>>>>>>", w_attrs)

        attrs[r_type] = dict()
        attrs[r_type]['def_r_attr'] = []
        attrs[r_type]['might_r_attr'] = []

        attrs[w_type] = dict()
        attrs[w_type]['def_r_attr'] = []
        attrs[w_type]['might_r_attr'] = []

        for attr in r_attrs:
            if attr in p.attrs_in_matching_policies(r_type, w_type, a_type):
                attrs[r_type]['def_r_attr'].append(attr)
            else:
                attrs[r_type]['might_r_attr'].append(attr)

        for attr in w_attrs:
            if attr in p.attrs_in_matching_policies(r_type, w_type, a_type):
                attrs[r_type]['def_r_attr'].append(attr)
            else:
                attrs[r_type]['might_r_attr'].append(attr)

        return attrs

    def update_req(x, payload, next_msg_type):
        attrs = self.analyze_policies(payload)
        def_read_attrs = attrs[x['type']]['def_r_attr']
        might_read_attrs = attrs[x['type']]['might_r_attr']

        # print(">>>>>>>", x['type'])
        # print(">>>>>>>", def_read_attrs, might_read_attrs)
        # print(">>>>>>>", payload)
        attr_to_be_updated = []
        for req_id in self.write_updates_cache:
            attr_to_be_updated.extend(write_updates_cache[req_id])

        attr_to_be_updated = set(attr_to_be_updated)
        req_attrs = set(def_read_attrs+might_read_attrs)


        self.starvation_q[payload['eval_id']] = (req_attrs, x, next_msg_type, payload)
        if len(attr_to_be_updated.intersection(req_attrs)) == 0:
            wait_payload = dict(app_id=payload['app_id'],
                                eval_id=payload['eval_id'])

            send(('STARVATION_WAIT_DONE', wait_payload,), to=x['coord'])
            self.logger.info('[SENT][STARVATION_WAIT_DONE][{}] payload:{}'
                                .format(wait_payload['app_id'], wait_payload))

    def update_attr_db(app_id, updated_obj, ts):
        data = dict(type=updated_obj['type'],
                    id=updated_obj['id'],
                    updates=updated_obj['updates'],
                    ts=ts)
        db_payload = dict(app_id=app_id,
                          data=data)
        # # Hacks to introduce artifical delays for simulating few tests
        # if 'before_db_read' in payload['delays']:
        #     time.sleep(10)

        send(('DB_WRITE_REQUEST', db_payload), to=db_ps)
        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'
                                            .format(db_payload['app_id'], db_payload))

    def receive(msg= ('COORDR_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][COORDR_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        # print ("before>>>>>>>>",self.attr_version)
        x = payload['r_obj']
        payload['eval_id'] = str(uuid.uuid4())
        payload['ts'] = time.time()*1000000
        payload['app_ps'] = p
        self.update_req(x, payload, 'COORDW_REQUEST')
        # print ("after>>>>>>>>",self.attr_version)


    def receive(msg= ('COORDR_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][COORDR_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))

        x = payload['obj']
        attrs = self.analyze_policies(payload)

        might_read_attrs = attrs[x['type']]['might_r_attr']

        if payload['req_type'] == const.READ_WRITE:
            might_read_attrs.extend(attrs[x['type']]['def_r_attr'])

        # print ("before>>>>>>>>", self.attr_version)
        for attr in might_read_attrs:
            v = self.latest_version_before(x, attr, payload['ts'])
            # print ("before!!!!!!!",(x, attr, payload['ts']), v)
            v['pending_might_read'] = [y for y in v['pending_might_read'] if y[0] != payload['eval_id']]
            if attr in payload['read_attrs']:
                v['rts'] = payload['ts']

            if len(v['pending_might_read']) == 0:
                for eval_id in self.req_q:
                    attr_v, req_payload = self.req_q[eval_id]
                    del attr_v[(x['type'], attr, payload['ts'])]
                    if len(attr_v) == 0:
                        wait_payload = dict(app_id=req_payload['app_id'],
                                            eval_id=eval_id)
                        send(('WAIT_DONE', wait_payload,), to=req_payload['w_obj']['coord'])
                        self.logger.info('[SENT][WAIT_DONE][{}] payload:{}'
                                            .format(wait_payload['app_id'], wait_payload))

            # print ("after!!!!!!!",(x, attr, payload['ts']), v)

        # print ("after>>>>>>>>",self.attr_version)
        self.logger.info('[PROCESSED][COORDR_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))

    def receive(msg= ('COORDW_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][COORDW_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        # print ("before>>>>>>>>",self.attr_version)
        x = payload['w_obj']
        self.update_req(x, payload, 'WORKER_REQUEST')


    def receive(msg= ('COORDW_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][COORDW_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        if not check_conflict(payload):
            x = payload['updated_obj']
            attr_updates = x['updates']
            write_updates_cache[payload['eval_id']] = attr_updates.keys()

            attr_v = []
            #await
            for attr in attr_updates:
                v = latest_version_before (x, attr, payload['ts'])
                if len(v['pending_might_read']):
                    attr_v.append((x['type'], attr, payload['ts']))

            self.req_q[payload['eval_id']] = (attr_v, payload)

            if len(attr_v) == 0:
                wait_payload = dict(app_id=payload['app_id'],
                                    eval_id=payload['eval_id'])
                send(('WAIT_DONE', wait_payload,), to=payload['w_obj']['coord'])
                self.logger.info('[SENT][WAIT_DONE][{}] payload:{}'
                                    .format(wait_payload['app_id'], wait_payload))
                # send wait done
        else:
            restart(payload)

    def receive(msg= ('WAIT_DONE', payload), from_=p):
        self.logger.info('[RECEIVED][WAIT_DONE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        _, payload = self.req_q[payload['eval_id']]
        del self.req_q[payload['eval_id']]
        if not check_conflict(payload):
            x = payload['updated_obj']
            # attr_updates = x['updates']
            update_attr_db(payload['app_id'], x, payload['ts'])

            del write_updates_cache[payload['eval_id']]

            attr_to_be_updated = []
            for req_id in self.write_updates_cache:
                attr_to_be_updated.extend(write_updates_cache[req_id])
            attr_to_be_updated = set(attr_to_be_updated)
            for req_id in self.starvation_q:
                req_attrs, x, next_msg_type, payload = self.starvation_q[req_id]
                if len(attr_to_be_updated.intersection(req_attrs)) == 0:
                    wait_payload = dict(app_id=payload['app_id'],
                                        eval_id=payload['eval_id'])

                    send(('STARVATION_WAIT_DONE', wait_payload,), to=x['coord'])
                    self.logger.info('[SENT][STARVATION_WAIT_DONE][{}] payload:{}'
                                        .format(wait_payload['app_id'], wait_payload))

            for attr in x['updates']:
                key = (x['type'], x['id'], attr)
                attr_cache[key] = x['updates'][attr]

            for attr in x['updates']:
                key = (x['type'], attr, payload['ts'])
                attr_version[key] = dict(rts=payload['ts'],
                                         wts=payload['ts'],
                                         pending_might_read=[])

            attrs = analyze_policies(payload)
            def_read_attrs = attrs[x['type']]['def_r_attr']
            might_read_attrs = attrs[x['type']]['might_r_attr']

            for attr in set(def_read_attrs+might_read_attrs):
                v = latest_version_before(x, attr, payload['ts'])
                v['pending_might_read'] = [y for y in v['pending_might_read'] if y[0] != payload['eval_id']]
                if attr in payload['read_attrs'][x['type']]:
                    v['rts'] = payload['ts']

                if len(v['pending_might_read']) == 0:
                    for eval_id in self.req_q:
                        attr_v, req_payload = self.req_q[eval_id]
                        del attr_v[(x['type'], attr, payload['ts'])]
                        if len(attr_v) == 0:
                            wait_payload = dict(app_id=req_payload['app_id'],
                                                eval_id=eval_id)
                            send(('WAIT_DONE', wait_payload,), to=req_payload['w_obj']['coord'])
                            self.logger.info('[SENT][WAIT_DONE][{}] payload:{}'
                                                .format(wait_payload['app_id'], wait_payload))


            client_resp_payload = dict(result=payload['decision'],
                                   app_id=payload['app_id'])

            send(('CLIENT_RESPONSE', client_resp_payload), to=payload['app_ps'])
            self.logger.info('[SENT][CLIENT_RESPONSE][{}] payload:{}'
                                        .format(client_resp_payload['app_id'],
                                                client_resp_payload))

            if x['type'] == payload['w_obj']['type']:
                payload['obj'] = payload['r_obj']

            else:
                payload['obj'] = payload['w_obj']

            payload['read_attrs'] = payload['read_attrs'].get(payload['obj']['type'],{})
            send(('COORDR_RESPONSE', payload), to=payload['obj']['coord'])
            self.logger.info('[SENT][COORDR_RESPONSE][{}] payload:{}'
                                        .format(payload['app_id'],
                                                payload))
        else:
            restart(payload)

    def receive(msg= ('STARVATION_WAIT_DONE', wait_payload), from_=p):
        self.logger.info('[RECEIVED][STARVATION_WAIT_DONE][{}] payload:{}'
                                        .format(wait_payload['app_id'],
                                                wait_payload))

        _, x, next_msg_type, payload = self.starvation_q[wait_payload['eval_id']]
        del self.starvation_q[wait_payload['eval_id']]
        attrs = self.analyze_policies(payload)
        def_read_attrs = attrs[x['type']]['def_r_attr']
        might_read_attrs = attrs[x['type']]['might_r_attr']

        if payload['req_type'] == const.READ_ONLY:
            for attr in def_read_attrs:
                v = self.latest_version_before(x, attr, time.time())
                v['rts'] = payload['ts']
        else:
            might_read_attrs.extend(def_read_attrs)

        for attr in might_read_attrs:
            v = self.latest_version_before(x, attr, time.time())
            v['pending_might_read'].append((payload['eval_id'], payload['ts']))


        # Piggy backing on cached data
        for attr in set(def_read_attrs+might_read_attrs):
            # print(">>>>>>>", attr)
            # print("-------", x)

            key = (x['type'], x['id'], attr)
            if key in self.attr_cache:
                x['attr'][attr] = self.attr_cache[key]

        if next_msg_type == 'COORDW_REQUEST':
            send(('COORDW_REQUEST', payload),to=payload['w_obj']['coord'])

            self.logger.info('[SENT][COORDW_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        else:
            worker = self.get_worker()
            # print ("after>>>>>>>>",self.attr_version)
            send(('WORKER_REQUEST', payload), to=worker)
            self.logger.info('[SENT][WORKER_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'],
                                                    payload))

    def receive(msg= ('TIMER_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))


        # write_payload = dict(app_id=payload['app_id'], data=res)
        # send(('DB_WRITE_REQUEST', write_payload),to=db_ps)

        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'
                                      .format(payload['app_id'], payload))

class Worker(process):

    def setup(db_ps, config, suffix):
        self.logger = get_logger('worker_logger',
                                 config['worker_log'].format(suffix,
                                                             str(self)))
        self.requests = dict()


    def evaluate(db_payload, orig_payload):
        r_obj = db_payload['r_obj']
        w_obj = db_payload['w_obj']
        action = orig_payload['action']
        # orig_res, _ = self.requests[eval_id]
        # change attr values based on policy rules
        # evaluate the policies
        # res['old_attr'] = orig_res['attr']
        policy = PolicyParser()
        # status, new_sub, new_res, action = policy.evaluate(sub, res, action)
        result = policy.execute_policy(r_obj, w_obj, action)

        # print("Worker Evaluate >>>>>>> ", result)
        return result


    def setup_payload(app_id, eval_id, r_obj, w_obj):
        policy = PolicyParser()

        r_attrs = list(policy.get_all_attrs(r_obj['type']))
        w_attrs = list(policy.get_all_attrs(w_obj['type']))

        new_r_obj = dict(type=r_obj['type'], id=r_obj['id'], attr=r_attrs)
        new_w_obj = dict(type=w_obj['type'], id=w_obj['id'], attr=w_attrs)

        payload = dict(app_id=app_id,
                       eval_id=eval_id,
                       r_obj=new_r_obj,
                       w_obj=new_w_obj)

        return payload


    def run():
        await(False)


    def receive(msg= ('WORKER_REQUEST', payload), from_=p):

        self.logger.info('[RECEIVED][WORKER_REQUEST][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        self.requests[payload['eval_id']] = copy.deepcopy(payload)

        db_payload = setup_payload(payload['app_id'], payload['eval_id'],
                                                payload['r_obj'], payload['w_obj'])

        db_payload['ts'] = payload['ts']

        # # Hacks to introduce artifical delays for simulating few tests
        # if 'before_db_read' in payload['delays']:
        #     time.sleep(10)


        send(('DB_READ_REQUEST', db_payload), to=db_ps)

        self.logger.info('[SENT][DB_READ_REQUEST][{}] payload:{}'
                                            .format(db_payload['app_id'], db_payload))



    def receive(msg= ('DB_READ_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][DB_READ_RESPONSE][{}] payload:{}'
                                            .format(payload['app_id'], payload))
        eval_id = payload['eval_id']
        orig_payload = self.requests[eval_id]
        # payload['sub']['attr'].update(orig_sub['attr'])
        # payload['res']['attr'].update(orig_res['attr'])

        # if len(orig_res['attr']) == 0:
        #     orig_res['attr'] = copy.deepcopy(payload['res']['attr'])

        # result, sub, res, action = evaluate(payload['eval_id'], payload['sub'],
        #                                     payload['res'], orig_action,
        #                                     orig_res)
        # # print(result, sub, res, action)


        # payload['r_obj']['attr'].update()
        # if worker_resp_payload['res']['id'].isdigit():
        #     seconds = 20 - int(worker_resp_payload['res']['id'])
        # else:
        #     seconds = random.randint(1,10)
        # print ("sleeping {} by {}", worker_resp_payload['app_id'], seconds)
        # time.sleep(seconds)
        # if 'before_worker_response' in payload['delays']:
        #     time.sleep(10)

        payload['r_obj']['attr'].update(orig_payload['r_obj']['attr'])
        payload['w_obj']['attr'].update(orig_payload['w_obj']['attr'])

        result = evaluate(payload, orig_payload)

        if result['updated_obj'] is not None:
            orig_payload['read_attrs'] = result['read_attrs']
            orig_payload['updated_obj'] = result['updated_obj']
            orig_payload['decision'] = result['decision']

            if orig_payload['w_obj']['type'] == result['updated_obj']['type']:
                actual_w_coord = orig_payload['w_obj']['coord']
            else:
                actual_w_coord = orig_payload['r_obj']['coord']


            send(('COORDW_RESPONSE', orig_payload), to=actual_w_coord)

            self.logger.info('[SENT][COORDW_RESPONSE][{}] payload:{}'
                                        .format(orig_payload['app_id'],
                                                orig_payload))

        else:
            client_resp_payload = dict(result=result['decision'],
                                   app_id=payload['app_id'])


            send(('CLIENT_RESPONSE', client_resp_payload), to=orig_payload['app_ps'])

            self.logger.info('[SENT][CLIENT_RESPONSE][{}] payload:{}'
                                        .format(client_resp_payload['app_id'],
                                                client_resp_payload))

            r_type = orig_payload['r_obj']['type']
            orig_payload['read_attrs'] = result['read_attrs'].get(r_type,{})
            orig_payload['obj'] = orig_payload['r_obj']
            send(('COORDR_RESPONSE', orig_payload), to=orig_payload['obj']['coord'])

            self.logger.info('[SENT][COORDR_RESPONSE][{}] payload:{}'
                                        .format(orig_payload['app_id'],
                                                orig_payload))

            w_type = orig_payload['w_obj']['type']
            orig_payload['read_attrs'] = result['read_attrs'].get(w_type,{})
            orig_payload['obj'] = orig_payload['w_obj']
            send(('COORDR_RESPONSE', orig_payload), to=orig_payload['obj']['coord'])

            self.logger.info('[SENT][COORDR_RESPONSE][{}] payload:{}'
                                        .format(orig_payload['app_id'],
                                                orig_payload))



def parse_client_requests(fpath):
    """ Method to parse client request file """
    with open(fpath, 'r') as f:
        cli_data = f.read()
        json_content = json.dumps(xmltodict.parse(cli_data)).replace('@','')
        requests = json.loads(json_content)['requests']['request']

    return requests


def gen_reqs(conf):
    total_reqs = conf['num_clients'] * conf['workload']
    reqs = []
    test_truth = dict()
    while total_reqs > len(reqs):
        # shuffle(conf['subs'])
        # shuffle(conf['res'])
        conf['subs'] = conf['subs'][1:]
        conf['subs'].append('A')
        for sub in conf['subs']:
            # sub_id = str(random.randint(1, conf['num_clients']/2))
            sub_id = str(random.randint(1,1))
            for res in conf['res']:

                # res_id = str(random.randint(1, conf['num_clients']/2))
                res_id = str(random.randint(1,1))
                req = {
                    'sub': {
                        'type':sub,
                        'id':sub_id
                    },
                    'res': {
                        'type':res,
                        'id':res_id
                    },
                    'action' : {
                        'type':conf['action']
                    }
                }
                if sub.lower() == res:
                    key = (res, res_id, 'viewCount')
                    if key in test_truth:
                        test_truth[key] += 1
                    else:
                        test_truth[key] = 1
                reqs.append(req)

    print(test_truth)
    # print (len(reqs))
    with open(conf['test_truth_path'], 'w') as f:
        f.write(json.dumps(str(test_truth)))

    with open(conf['path'],'w') as f:
        f.write(json.dumps(reqs))

    return reqs


def main():
    DEFAULT_MAIN_CONFIG = "../config/main-config.json"
    config_fpath = sys.argv[1] if len(sys.argv) > 1 else DEFAULT_MAIN_CONFIG
    config = cfg.load_config(config_fpath)
    config(channel="reliable")

    for test in config['testing']:
        suffix = test['log_suffix']
        p_time = test['p_time']
        if test.get('generate', None):
            cli_requests = gen_reqs(test)
            test['workload'] = [test['workload']] * test['num_clients']
        else:
            cli_requests = parse_client_requests(test['path'])
            if test['randomize']:
                random.seed(test['seed'])
                shuffle(cli_requests)

        types = set([x['sub']['type'] for x in cli_requests])
        types = types.union(set([x['res']['type'] for x in cli_requests]))
        coord_map = dict()
        for type in types:
            coord_map[type] = len(coord_map)

        # print ('coord_map', coord_map)

        # Setup and start DBEmulator
        db_ps = new(DBEmulator, args=(config, suffix, p_time,))
        # setup(db_ps,)
        start(db_ps)

        # Setup and start Workers
        worker_ps = new(Worker, num=test['num_coords']*test['worker_count'], args=(db_ps, config, suffix,))
        # setup(worker_ps,)
        start(worker_ps)

        # Setup and start Resource Coordinators

        workers_p = list(worker_ps)
        start = 0
        coords = set()
        for i in range(test['num_coords']):
            coord_ps = new(Coord, args=(db_ps, workers_p[start:start+test['worker_count']], config, suffix,
                    coord_map,))
            # setup(p,)
            start(coord_ps)
            coords.add(coord_ps)
            start += test['worker_count']


        # Setup and start Application instances

        print (coords)
        i = 0
        start = 0

        for i in range(test['num_clients']):
            app_ps = new(Application, num=1, args=(coords, config,
                        cli_requests[start:start+test['workload'][i]], suffix,
                        coord_map,))
            # setup(p, )
            start += test['workload'][i]
            i += 1
            start(app_ps)
            if test.get('serialize_app_req_delay', None):
                time.sleep(1)


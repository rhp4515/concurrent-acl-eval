import logging
import sys
import csv
import config as cfg
import constants as const
import xmltodict, json
import pandas as pd
import random
import uuid
import time
from threading import Lock
from tabulate import tabulate
from policy import PolicyParser

def get_logger(name, path):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)
    handler = logging.FileHandler(path, mode='w')
    handler.setLevel(logging.DEBUG)
    logger.addHandler(handler)
    logger.disabled = True
    return logger

class TimerP(process):
    def setup(config):
        self.logger = get_logger('timer_logger', config['timer_log'])

    def run():
        # Kill after sending one message
        await(received(('DONE',)))


    def receive(msg= ('TIMER_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        time.sleep(payload['latency_in_secs'])
        del payload['latency_in_secs']
        send(('TIMER_RESPONSE', payload),to=p)
        self.logger.info('[SENT][TIMER_RESPONSE][{}] payload:{}'.format(payload['app_id'], payload))
        send(('DONE',),to=self.id)

class DBEmulator(process):
    def setup(config):
        self.conf = config['db_config']
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.logger = get_logger('db_logger', config['db_log'])
        self.attr_db = {}

        with open(self.conf, 'r') as f:
            db_data = f.read()

        json_content = json.loads(json.dumps(xmltodict.parse(db_data)))['db']

        json_data = json_content['data']
        # print(json_data)
        for ent_type in json_data:
            if type(json_data[ent_type]) == dict:
                json_data[ent_type] = [json_data[ent_type]]
            for data in json_data[ent_type]:
                # print(data)
                for attr in data['attr']:
                    key = (ent_type, data['id'], attr)
                    val = data['attr'][attr]
                    # print(attr, val)
                    if not val:
                        val = 0 if attr in const.NUMERICAL_ATTR else ''
                    # print('setting attr db')
                    self.attr_db[key] = int(val) if attr in const.NUMERICAL_ATTR else val
        # print(json_data)            
        # print (self.attr_db)

    def run():
        # print(self.tables)
        await(False)

    def _read(data):
        resp = dict(type=data['type'], id=data['id'], attr=dict())
        for attr_name in data['attr']:
            # print (attr_name)
            key = (data['type'], data['id'], attr_name)
            val = None
            if key in self.attr_db:
                val = self.attr_db[key]
            else:
                val = 0 if attr_name in const.NUMERICAL_ATTR else ''
                self.attr_db[key] = val

            resp['attr'][attr_name] = val

        return resp


    def _write(data):
        for attr in data['attr']:
            key = (data['type'], data['id'], attr)
            self.attr_db[key] = data['attr'][attr]

        return None

    def _op(fn, data):
        return fn(data)

    def receive(msg=('DB_READ_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_READ_REQUEST][{}] payload:{}'.format(data['app_id'], data))
        sub = self._op(self._read, data['sub'])
        res = self._op(self._read, data['res'])
        payload = dict(sub=sub, res=res, eval_id=data['eval_id'], app_id=data['app_id'])
        send(('DB_READ_RESPONSE', payload), to=p)
        self.logger.info('[SENT][DB_READ_RESPONSE][{}] payload:{}'.format(data['app_id'],payload))

    def receive(msg=('DB_WRITE_REQUEST', data), from_=p):
        self.logger.info('[RECEIVED][DB_WRITE_REQUEST][{}] payload:{}'.format(data['app_id'], data))
        self._op(self._write, data['data'])

# Client corresponds to Application instance
class Application(process):
    def setup(sub_coord_ps, config, requests):
        self.logger = get_logger('app_logger', config['app_log'])
        self.sub_coord_map = dict()
        self.requests = requests
        # Creating an app id for the subject coordinator to send the response
        # to corresponding application
        self.app_id = str(uuid.uuid4())
        self.results = []

    # Assuming sub coordinator id as INTEGER
    def get_sub_coord(sub):
        sub_coords = list(sub_coord_ps)
        sub_coords.sort(key= lambda k: k._address[1])
        if sub['type'] not in sub_coord_map:
            self.sub_coord_map[sub['type']] = len(self.sub_coord_map)

        chosen = sub_coords[int(self.sub_coord_map[sub['type']])%len(sub_coords)]
        self.logger.info('SENDING SUB ID - {} TO PROCESS {}'.format(sub['id'], chosen))
        return chosen

    def authorize(sub, res, action):
        # time.sleep(1)
        # TODO: why do we need attr at the beginning
        if 'attr' not in sub:
            sub['attr'] = {}
        if 'attr' not in res:
            res['attr'] = {}

        payload = {
            'sub': sub,
            'res': res,
            'action': action,
            'app_id': self.app_id
        }
        p = get_sub_coord(sub)

        send(('APP_EVALUATION_REQUEST',payload), to=p)
        self.logger.info('[SENT][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(self.app_id, payload))

    def run():
        # if len(self.requests) > 0:
        #     request = self.requests[0]
        #     authorize(request['sub'], request['res'], request['action'])

        # await(sent(('DONE',)))
        # self.requests = self.requests[1:]
        # self.logger.info('[RECEIVED][DONE]')
        for request in self.requests:
            authorize(request['sub'], request['res'], request['action'])
            await(sent(('DONE',)))
            self.logger.info('[RECEIVED][DONE]')

    def receive(msg=('APP_EVALUATION_RESPONSE', payload), from_=p):
        app_id = payload['app_id']
        self.logger.info('[RECEIVED][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_id, payload))
        self.results.append(payload)
        send(('DONE',), to=self.id)


class SubCoord(process):
    def setup(db_ps, res_coord_ps, config):
        self.logger = get_logger('sub_coord_logger', config['sub_coord_log'])
        self.app_req_map = dict()
        columns = ['eval_id','sub', 'res', 'action', 'dep_eval_ids', 'status', 'req_no','result']
        self.eval_cache = pd.DataFrame([], columns=columns)
        self.attr_cache = dict()
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']
        self.res_coord_map = dict()
        self.res_commit_q = dict()

    def get_res_coord(res):
        res_coords = list(res_coord_ps)
        res_coords.sort(key= lambda k: k._address[1])
        if res['type'] not in res_coord_map:
            self.res_coord_map[res['type']] = len(self.res_coord_map)
        chosen = res_coords[int(self.res_coord_map[res['type']])%len(res_coords)]
        self.logger.info('SENDING RES ID - {} TO PROCESS {}'.format(res['id'], chosen))
        return chosen

    def get_eval(eval_id):
        row = self.eval_cache[(self.eval_cache['eval_id'] == eval_id)]
        if len(row) > 0:
            return json.loads(row.iloc[0].to_json())
        else:
            return None


    def run():
        # await(received(('done', )))
        await(False)

    def setup_cache(eval_id, sub, res, action, dep_eval_ids, req_no, status):
        self.logger.info('[SETUP CACHE] [{}]'.format(eval_id))
        data = {'eval_id': eval_id,
                'sub': sub,
                'res': res,
                'action': action,
                'dep_eval_ids': dep_eval_ids,
                'req_no': req_no,
                'status':status,
                'result':None}
        # print ("SETUP CACHE - BEFORE")
        # print (tabulate(self.eval_cache, headers='keys', tablefmt='grid')) 
        self.eval_cache.loc[len(self.eval_cache)] = data
        # print ("SETUP CACHE - AFTER")
        # print (tabulate(self.eval_cache, headers='keys', tablefmt='grid'))

    def update_cache(eval_id, status):
        self.logger.info('[UPDATING CACHE] [{}]'.format(eval_id))
        self.eval_cache.loc[self.eval_cache['eval_id'] == eval_id, 'status'] = status

    def update_dep_evals(eval_id, dep_eval_ids):
        self.logger.info('[UPDATING DEP EVALS] [{}]'.format(eval_id))
        indices = self.eval_cache.loc[(self.eval_cache['eval_id'] == eval_id)].index.tolist()

        if indices:
            self.eval_cache.set_value(indices[0],'dep_eval_ids', dep_eval_ids)

    def update_attr(eval_id, sub, res, result):
        self.logger.info('[UPDATING ATTR] [{}]'.format(eval_id))
        indices = self.eval_cache.loc[(self.eval_cache['eval_id'] == eval_id)].index.tolist()

        if indices:
            self.eval_cache.set_value(indices[0],'sub', sub)
            self.eval_cache.set_value(indices[0],'res', res)
            self.eval_cache.set_value(indices[0],'result', result)

    def clear_cache(eval_id):
        self.logger.info('[CLEAR CACHE] [{}]'.format(eval_id))
        idx = self.eval_cache.loc[self.eval_cache['eval_id'] == eval_id].index.tolist()
        # print(idx)
        # print ("CLEAR CACHE - BEFORE")
        # print (tabulate(self.eval_cache, headers='keys', tablefmt='grid'))                        
        self.eval_cache.drop(idx, inplace=True)
        # print ("CLEAR CACHE - AFTER")
        # print (tabulate(self.eval_cache, headers='keys', tablefmt='grid'))                        
        del self.app_req_map[eval_id]

    def restart(eval_id):
        self.logger.info('***[RESTARTING SELF]***')
        print('***[RESTARTING SELF]***')
        # eval = get_eval(eval_id)
        payload = {
            'sub': app_req_map[eval_id]['sub'],
            'res': app_req_map[eval_id]['res'],
            'action': app_req_map[eval_id]['action'],
            'app_id': app_req_map[eval_id]['app_id']
        }
        clear_cache(eval_id)
        send(('APP_EVALUATION_REQUEST',payload), to=self.id)
        self.logger.info('[SENT[APP_EVALUATION_REQUEST][{}] to [{}] payload:{}'
                         .format(payload['app_id'], self.id, payload))


    def add_tentative_attr_updates_to_req(sub, req_no):
        tentative_evals = get_previous_committed_evals(req_no)
        print ("TENTATIVE_EVALS", sub, req_no, [x['eval_id'] for x in tentative_evals])
        for eval in tentative_evals:
            attrs = eval['sub']['attr']
            sub['attr'].update(attrs)
        return sub, [eval['eval_id'] for eval in tentative_evals]

    def has_subject_attr_updates(eval_id):
        curr_eval = get_eval(eval_id)
        sub_attrs = curr_eval['sub']['attr']
        tentative_evals = get_tentative_evals(curr_eval['sub'], curr_eval['req_no'])
        tentative_attrs = {}
        for eval in tentative_evals:
            for k in sub_attrs:
                if k in eval['sub']['attr']:
                    tentative_attrs[k] = sub_attrs[k]

        for k in tentative_attrs:
            if tentative_attrs[k] != sub_attrs[k]:
                return True

        return False

    def clean_up(df):
        # self.eval_cache.loc[self.eval_cache['eval_id'] == eval_id].index.tolist()
        columns = ['eval_id','sub', 'res', 'action', 'dep_eval_ids', 'status', 'req_no','result']
        for col in columns:
            idx = df.loc[df['eval_id'] == col].index.tolist()
            df.drop(idx, inplace=True)
        # print(df.dtypes)
        return df

    def evaluate(app_id, sub, res, action, req_no, p):
        eval_id = str(uuid.uuid4())
        app_req_map[eval_id] = dict(app_id=app_id, sub=sub, res=res, action=action, req_no=req_no, app_p=p)
        # if sub['id'] == '3':
        #     print ("sleeping for ", 5, eval_id)
        #     time.sleep(5)       

        sub, dependent_eval_ids = add_tentative_attr_updates_to_req(sub, req_no)
        setup_cache(eval_id, sub, res, action, dependent_eval_ids, req_no, const.PENDING)
        # print (tabulate(self.eval_cache, headers='keys', tablefmt='grid'))
        return eval_id, sub

    def get_tentative_evals(sub, req_no):
        clean_up(self.eval_cache)
        # self.eval_cache[['req_no']] = self.eval_cache[['req_no']].astype(float)
        evals = self.eval_cache[(self.eval_cache['status'] == const.WORKER_COMPLETE) & (self.eval_cache['req_no'] < req_no)]
        # print (tabulate(evals, headers=['eval_id','req_no','status'], tablefmt='grid'))
        evals = evals.sort_values('req_no', ascending=True)
        # print (tabulate(evals, headers=['eval_id','req_no','status'], tablefmt='grid'))
        evals = json.loads(evals.to_json(orient="records"))
        eval_with_sub_attrs = []

        for eval in evals:
            for k in sub['attr']:
                if k in eval['sub']['attr']:
                    eval_with_sub_attrs.append(eval)
                    break

        return eval_with_sub_attrs

    def get_evals_dependent_on(eval_id):
        curr_eval = get_eval(eval_id)
        clean_up(self.eval_cache)
        # self.eval_cache[['req_no']] = self.eval_cache[['req_no']].astype(float)
        print ('CACHE TABLE')
        print (tabulate(self.eval_cache, headers='keys',tablefmt='grid'))        
        evals = self.eval_cache[self.eval_cache['req_no'] > curr_eval['req_no']]
        evals = evals.sort_values('req_no', ascending=True)
        evals = json.loads(evals.to_json(orient="records"))
        result = []
        for eval in evals:
            if eval_id in eval['dep_eval_ids']:
                result.append(eval)
        print ('QUERY RESULTS')
        print (result)
        return result

    def get_app(eval_id):
        return (self.app_req_map[eval_id]['app_id'], self.app_req_map[eval_id]['app_p'])

    def process_worker_response(eval_id):
        if has_subject_attr_updates(eval_id):
            restart(eval_id)
        else:
            update_cache(eval_id, const.WORKER_COMPLETE)
            curr_eval = get_eval(eval_id)
            tentative_evals = get_tentative_evals(curr_eval['sub'], curr_eval['req_no'])
            tentative_eval_ids = list(set([x['eval_id'] for x in tentative_evals]))
            if len(tentative_eval_ids) > 0:
                update_dep_evals(eval_id, tentative_eval_ids)
                self.res_commit_q[eval_id] = tentative_eval_ids
            else:
                print('process_worker_response returing TRUE')
                return True
        return False
        #     print ("**********************************************************")
        #     print (tabulate(self.eval_cache, headers='keys',tablefmt='grid'))
        #     print (curr_eval)
        #     print (tentative_eval_ids)
        #     print ("**********************************************************")
        #     if some(received(('RES_COMMIT_RESPONSE', payload)), has= payload['eval_id'] in tentative_eval_ids and payload['result'] == False):
        #         print('restarting eval_id = ', eval_id)
        #         restart(eval_id)
        #     else:
        #         return True, res
        # return False, res

    def get_previous_committed_evals(req_no):
        clean_up(self.eval_cache)
        evals = self.eval_cache[(self.eval_cache['status'] == const.WORKER_COMPLETE) & (self.eval_cache['req_no'] < req_no)]
        evals = evals.sort_values('req_no', ascending=True)
        return json.loads(evals.to_json(orient="records"))

    def update_attr_db(app_id, sub):
        payload = dict(app_id=app_id, sub=sub)
        for attr in sub['attr']:
            key = (sub['type'], sub['id'], attr)
            self.attr_cache[key] = sub['attr'][attr]

        seconds = random.randint(self.minLatency,self.maxLatency)
        payload = dict(app_id=app_id, latency_in_secs=seconds, sub=sub)

        timer_ps = new(TimerP, num=1)
        setup(timer_ps,(config,))
        start(timer_ps)

        send(('TIMER_REQUEST', payload),to=timer_ps)
        self.logger.info('[SENT][TIMER_REQUEST][{}] payload:{}'.format(app_id, payload))

    def restart_dependent_evals(eval_id):
        print ("restarting dependant evals")
        evals = get_evals_dependent_on(eval_id)
        for eval in evals:
            restart(eval['eval_id'])

    def add_latest_db_updates(sub):
        ignore_attrs = []
        for attr in sub['attr']:
            key = (sub['type'], sub['id'], attr)
            if key in self.attr_cache:
                sub['attr'][attr] = self.attr_cache[key]
                del self.attr_cache[key]
            else:
                ignore_attrs.append(attr)

        for attr in ignore_attrs:
            del sub['attr'][attr]

        return sub
    
    def get_pending_transactions_to_commit():
        # print("IN MY METHOD")
        commited_eval_ids = []
        # print (tabulate(self.eval_cache, headers=['req_no'],tablefmt='grid'))
        # self.eval_cache[['req_no']] = self.eval_cache[['req_no']].astype(float)
        # print (tabulate(self.eval_cache, headers=['req_no'],tablefmt='grid'))
        clean_up(self.eval_cache)
        self.eval_cache.sort_values('req_no', ascending=True, inplace=True)
        evals = json.loads(self.eval_cache.to_json(orient="records"))
        # print (evals)
        for eval in evals:
            if eval['status'] != const.PENDING_ATTR_DB_UPDATE:
                break
            else:
                commited_eval_ids.append(eval['eval_id'])
        
        return commited_eval_ids
            
    def receive(msg= ('APP_EVALUATION_REQUEST', payload), from_=p):
        # print (tabulate(self.eval_cache, headers='keys',tablefmt='psql'))
        self.logger.info('[RECEIVED][APP_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))

        res = payload['res']
        eval_id, sub = evaluate(payload['app_id'],
                                payload['sub'],
                                payload['res'],
                                payload['action'],
                                time.time(),
                                p)

        res_req_payload = dict(app_id=payload['app_id'],
                               eval_id=eval_id,
                               sub=sub,
                               res=res,
                               action=payload['action'])

        send(('RES_EVALUATION_REQUEST', res_req_payload),to=get_res_coord(res))
        self.logger.info('[SENT][RES_EVALUATION_REQUEST][{}] payload:{}'
                         .format(res_req_payload['app_id'], res_req_payload))

    def receive(msg= ('WORKER_EVALUATION_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        eval = get_eval(payload['eval_id'])
        if not eval:
            self.logger.info('[IGNORED][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
            return
        update_attr(payload['eval_id'], payload['sub'], payload['res'], payload['result'])
        status = process_worker_response(payload['eval_id'])
        # print("*********",status, res, "***********")
        # If control comes here then it should have been successful
        # Upon failure the process is restarted

        if status:
            res_commit_payload = dict(eval_id=payload['eval_id'],
                                  app_id=payload['app_id'],
                                  res=payload['res'])
            send(('RES_COMMIT_REQUEST', res_commit_payload),to=get_res_coord(payload['res']))
            self.logger.info('[SENT][RES_COMMIT_REQUEST][{}] payload:{}'
                         .format(res_commit_payload['app_id'], res_commit_payload))
            print('[SENT][RES_COMMIT_REQUEST][{}] payload:{}'
                                     .format(res_commit_payload['app_id'], res_commit_payload))

            res_commit_req_done_payload = dict(app_id=payload['app_id'],
                                               eval_id=payload['eval_id'])

            send(('RES_COMMIT_REQ_DONE', res_commit_req_done_payload),to=self.id)
            self.logger.info('[SENT][RES_COMMIT_REQ_DONE][{}] payload:{}'
                        .format(res_commit_req_done_payload['app_id'], 
                                res_commit_req_done_payload))
            print('[SENT][RES_COMMIT_REQ_DONE][{}] payload:{}'
                        .format(res_commit_req_done_payload['app_id'], 
                                res_commit_req_done_payload))


    def receive(msg= ('RES_COMMIT_REQ_DONE', payload), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_REQ_DONE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        print('[RECEIVED][RES_COMMIT_REQ_DONE][{}] payload:{}'
                         .format(payload['app_id'], payload))

        evals_to_send_commit = []
        evals = get_evals_dependent_on(payload['eval_id'])
        print('RES_COMMIT_REQ_DONE', 'get_evals_dependent_on', [x['eval_id'] for x in evals])
        for eval in evals:
            eval_id = eval['eval_id']
            if eval_id in self.res_commit_q:
                self.res_commit_q[eval_id].remove(payload['eval_id'])
                evals_to_send_commit.append(eval_id)
        
        for eval_id in evals_to_send_commit:
            curr_eval = get_eval(eval_id)
            res_commit_payload = dict(eval_id=eval_id,
                                  app_id=get_app(eval_id)[0],
                                  res=curr_eval['res'])
            send(('RES_COMMIT_REQUEST', res_commit_payload),to=get_res_coord(curr_eval['res']))
            self.logger.info('[SENT][RES_COMMIT_REQUEST][{}] payload:{}'
                         .format(res_commit_payload['app_id'], res_commit_payload))

    def receive(msg= ('RES_COMMIT_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        res_commit_req_done_payload = dict(app_id=payload['app_id'],
                                               eval_id=payload['eval_id'])

        send(('RES_COMMIT_REQ_DONE', res_commit_req_done_payload),to=self.id)
        self.logger.info('[SENT][RES_COMMIT_REQ_DONE][{}] payload:{}'
                    .format(res_commit_req_done_payload['app_id'], 
                            res_commit_req_done_payload))
        print('[SENT][RES_COMMIT_REQ_DONE][{}] payload:{}'
                    .format(res_commit_req_done_payload['app_id'], 
                            res_commit_req_done_payload))
        eval = get_eval(payload['eval_id'])
        if not eval:
            self.logger.info('[IGNORED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
            return

        print ('[RECEIVED][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))
        result = payload['result']
        if result:
            # commit_eval(payload['app_id'], payload['eval_id'])
            update_cache(payload['eval_id'], const.PENDING_ATTR_DB_UPDATE)
            send(('RES_COMMIT_DONE'), to=self.id)
            print('[SENT][RES_COMMIT_DONE]')

        else:
            restart_dependent_evals(payload['eval_id'])
            restart(payload['eval_id'])

    def receive(msg= ('RES_COMMIT_DONE'), from_=p):
        self.logger.info('[RECEIVED][RES_COMMIT_DONE]')
        eval_ids = get_pending_transactions_to_commit()
        
        for eval_id in eval_ids:
            app_id, app_ps = get_app(eval_id)
            eval = get_eval(eval_id)
            update_attr_db(app_id, eval['sub'])
            clear_cache(eval_id)
            app_eval_payload = dict(result=eval['result'], app_id=app_id)
            send(('APP_EVALUATION_RESPONSE', app_eval_payload),to=app_ps)
            self.logger.info('[SENT][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_eval_payload['app_id'], app_eval_payload))
            print('[SENT][APP_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(app_eval_payload['app_id'], app_eval_payload))

    def receive(msg= ('TIMER_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))

        sub = add_latest_db_updates(payload['sub'])

        write_payload = dict(app_id=payload['app_id'], data=sub)
        send(('DB_WRITE_REQUEST', write_payload),to=db_ps)
        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'.format(payload['app_id'], write_payload))

class ResCoord(process):
    def setup(db_ps, workers, config):
        self.logger = get_logger('res_coord_logger', config['res_coord_log'])
        self.res_cache = dict()
        self.next_worker_idx = -1
        self.workers = list(workers)
        self.attr_cache = dict()
        self.minLatency = config['minDBlatency']
        self.maxLatency = config['maxDBlatency']

    def run():
        await(False)

    # Selects worker in a round robin fashion
    def get_worker():
        self.next_worker_idx += 1
        return self.workers[next_worker_idx%len(self.workers)]

    def setup_res_attr(res):
        key = (res['type'], res['id'])
        if key in self.res_cache:
            res['attr'] = self.res_cache[key]

        return res

    def update_cache(res):
        key = (res['type'], res['id'])
        self.res_cache[key] = res['attr']


    def conflict_exists(res):
        key = (res['type'], res['id'])
        if key not in self.res_cache:
            return False

        cache_res = self.res_cache[key]
        for attr in res['old_attr']:
            if attr in cache_res and res['old_attr'][attr] != cache_res[attr]:
                return True

        return False


    def update_attr_db(app_id, res):
        payload = dict(app_id=app_id, res=res)
        for attr in res['attr']:
            key = (res['type'], res['id'], attr)
            self.attr_cache[key] = res['attr'][attr]

        seconds = random.randint(self.minLatency,self.maxLatency)
        payload = dict(app_id=app_id, latency_in_secs=seconds, res=res)

        timer_ps = new(TimerP, num=1)
        setup(timer_ps,(config,))
        start(timer_ps)

        send(('TIMER_REQUEST', payload),to=timer_ps)
        self.logger.info('[SENT][TIMER_REQUEST][{}] payload:{}'.format(app_id, payload))

    def commit_evaluation(app_id, eval_id, res):
        if conflict_exists(res):
            return False
        else:
            update_cache(res)
            update_attr_db(app_id, res)
            return True

    def add_latest_db_updates(res):
        ignore_attrs = []
        for attr in res['attr']:
            key = (res['type'], res['id'], attr)
            if key in self.attr_cache:
                res['attr'][attr] = self.attr_cache[key]
                del self.attr_cache[key]
            else:
                ignore_attrs.append(attr)

        for attr in ignore_attrs:
            del res['attr'][attr]

        return res

    def receive(msg= ('RES_EVALUATION_REQUEST', payload), from_=p):
        # print ("**************************************************")
        # print (self.res_cache)
        self.logger.info('[RECEIVED][RES_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        setup_res_attr(payload['res'])
        payload['sub_coord'] = p
        send(('WORKER_EVALUATION_REQUEST', payload),to=get_worker())

        self.logger.info('[SENT][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        # print (self.res_cache)
        # print ("**************************************************")

    def receive(msg= ('RES_COMMIT_REQUEST', payload), from_=p):
        # print ("**************************************************")
        # print (self.res_cache)
        self.logger.info('[RECEIVED][RES_COMMIT_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))

        result = commit_evaluation(payload['app_id'], payload['eval_id'], payload['res'])
        res_commit_payload = dict(eval_id=payload['eval_id'],
                                  result=result,
                                  app_id=payload['app_id'])
        # if payload['res']['id'].isdigit():
        #     seconds = 20 - int(payload['res']['id'])
        # else:
        #     seconds = random.randint(self.minLatency,self.maxLatency)
        # print ("sleeping {} by {}", payload['app_id'], seconds)
        # time.sleep(seconds)
        if payload['res']['id'] == "bank B":
            print('waiting to send res commit response')
            time.sleep(10)
        send(('RES_COMMIT_RESPONSE', res_commit_payload),to=p)
        self.logger.info('[SENT][RES_COMMIT_RESPONSE][{}] payload:{}'
                         .format(res_commit_payload['app_id'], res_commit_payload))
        # print (self.res_cache)
        # print ("**************************************************")

    def receive(msg= ('TIMER_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][TIMER_RESPONSE][{}] payload:{}'
                         .format(payload['app_id'], payload))

        res = add_latest_db_updates(payload['res'])

        write_payload = dict(app_id=payload['app_id'], data=res)
        send(('DB_WRITE_REQUEST', write_payload),to=db_ps)
        self.logger.info('[SENT][DB_WRITE_REQUEST][{}] payload:{}'.format(payload['app_id'], write_payload))

class Worker(process):
    def setup(db_ps, config):
        self.logger = get_logger('worker_logger', config['worker_log'])
        self.requests = dict()
        self.policy = PolicyParser()

    def evaluate(eval_id, sub, res, action, orig_res):
        # orig_res, _ = self.requests[eval_id]
        # change attr values based on policy rules
        # evaluate the policies
        res['old_attr'] = orig_res['attr']
        status, new_sub, new_res, action = self.policy.evaluate(sub, res, action)
        return status, new_sub, new_res, action

    def setup_payload(app_id, eval_id, sub, res):
        payload = {
            'app_id' : app_id,
            'eval_id' : eval_id,
            'sub':{
                'type':sub['type'],
                'id':sub['id'],
                'attr': list(self.policy.get_sub_attr(sub, res))
            },
            'res':{
                'type':res['type'],
                'id':res['id'],
                'attr': list(self.policy.get_res_attr(sub, res))
            }
        }
        return payload


    def run():
        await(False)

    def receive(msg= ('WORKER_EVALUATION_REQUEST', payload), from_=p):
        self.logger.info('[RECEIVED][WORKER_EVALUATION_REQUEST][{}] payload:{}'
                         .format(payload['app_id'], payload))
        self.requests[payload['eval_id']] = (payload['sub'], payload['res'], payload['action'], payload['sub_coord'])

        # print(self.requests[payload['eval_id']])

        db_payload = setup_payload(payload['app_id'], payload['eval_id'], payload['sub'], payload['res'])

        db_payload['sub']['attr'] = [attr for attr in db_payload['sub']['attr'] if attr not in payload['sub']['attr']]
        db_payload['res']['attr'] = [attr for attr in db_payload['res']['attr'] if attr not in payload['res']['attr']]

        send(('DB_READ_REQUEST', db_payload), to=db_ps)
        self.logger.info('[SENT][DB_READ_REQUEST][{}] payload:{}'.format(payload['app_id'], payload))



    def receive(msg= ('DB_READ_RESPONSE', payload), from_=p):
        self.logger.info('[RECEIVED][DB_READ_RESPONSE][{}] payload:{}'.format(payload['app_id'], payload))

        orig_sub, orig_res, orig_action, sub_coord_ps = self.requests[payload['eval_id']]
        payload['sub']['attr'].update(orig_sub['attr'])
        payload['res']['attr'].update(orig_res['attr'])
        result, sub, res, action = evaluate(payload['eval_id'], payload['sub'], payload['res'], orig_action, orig_res)
        # print(result, sub, res, action)
        worker_resp_payload = dict(eval_id=payload['eval_id'],
                                   result=result,
                                   sub=sub,
                                   res=res,
                                   action=action,
                                   app_id=payload['app_id'])

        # if worker_resp_payload['res']['id'].isdigit():
        #     seconds = 20 - int(worker_resp_payload['res']['id'])
        # else:
        #     seconds = random.randint(1,10)
        # print ("sleeping {} by {}", worker_resp_payload['app_id'], seconds)
        # time.sleep(seconds)
        send(('WORKER_EVALUATION_RESPONSE', worker_resp_payload),to=sub_coord_ps)

        self.logger.info('[SENT][WORKER_EVALUATION_RESPONSE][{}] payload:{}'
                         .format(worker_resp_payload['app_id'], worker_resp_payload))


def parse_client_requests(fpath):
    with open(fpath, 'r') as f:
        cli_data = f.read()
        json_content = json.loads(json.dumps(xmltodict.parse(cli_data)).replace('@',''))['requests']
    return json_content['request']



def main():
    config_fpath = sys.argv[1] if len(sys.argv) > 1 else "../config/main-config.json"
    config = cfg.load_config(config_fpath)
    # do something with config
    config(channel="reliable")

    cli_requests = parse_client_requests(config['client_requests'])

    db_ps = new(DBEmulator, num=1)
    setup(db_ps,(config,))
    start(db_ps)

    worker_ps = new(Worker, num=config['num_coords']*config['worker_count'])
    setup(worker_ps,(db_ps, config,))
    start(worker_ps)

    res_coord_ps = new(ResCoord, num=config['num_coords'])
    setup(res_coord_ps,(db_ps, worker_ps, config,))
    start(res_coord_ps)

    sub_coord_ps = new(SubCoord, num=config['num_coords'])
    setup(sub_coord_ps,(db_ps, res_coord_ps, config,))
    start(sub_coord_ps)

    app_ps = new(Application, num=config['num_clients'])
    i = 0
    num_req_per_process = 1
    for p in app_ps:
        setup(p, (sub_coord_ps, config, cli_requests[i:i+num_req_per_process]))
        i += num_req_per_process
        start(p)
        time.sleep(1)
    # start(app_ps)



